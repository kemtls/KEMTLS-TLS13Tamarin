
define(<!lemma_matching_hsahsms!>, <!
lemma matching_hsahsms [reuse, heuristic=cS]:
  "All tid actor role hs hs2 ahs ms #i #j.
    commit(HS, actor, role, hs2)@i &
    running(HSAHSMS, actor, role, hs, ahs, ms)@j ==>
      hs = hs2"
!>)

define(<!lemma_matching_hsahs!>, <!
lemma matching_hsahs [reuse, heuristic=cS]:
  "All tid actor role hs hs2 ahs ss #i #j.
    commit(HS, actor, role, hs2)@i &
    running(HSAHS, actor, role, hs, ahs, ss)@j ==>
      hs = hs2"
!>)

define(<!lemma_matching_ahsms!>, <!
lemma matching_ahsms [reuse, heuristic=c]:
  "All tid actor role ahs ahs2 ms clauth_ss #i #j.
    commit(AHS, actor, role, ahs2)@i &
    running(AHSMS, actor, role, ahs, ms, clauth_ss)@j ==>
      ahs = ahs2"
!>)

define(<!lemma_matching_hsahsms_all!>, <!
lemma matching_hsahsms_all [reuse, heuristic=c]:
  "All tid actor role hs hs2 ahs ahs2 ms ms2 clauth_ss #i #j #k #l.
    commit(HS, actor, role, hs2)@i &
    commit(AHS, actor, role, ahs2)@j &
    commit(MS, actor, role, ms2)@k &
    running(HSAHSMS, actor, role, hs, ahs, ms, clauth_ss)@l ==>
      (hs = hs2 & ahs = ahs2 & ms = ms2)"
!>)

define(<!lemma_matching_ahsms_ms!>, <!
lemma matching_ahsms_ms [reuse, heuristic=c]:
  "All tid actor role ahs ms ms2 clauth_ss #i #j.
    commit(MS, actor, role, ms2)@i &
    running(AHSMS, actor, role, ahs, ms, clauth_ss)@j ==>
      ms = ms2"
!>)


lemma commit_identity_authsecret_consistency [reuse]:
  "All tid actor role peer pas cas #ctime.
    commit(Identity, actor, role, peer, <pas, cas>)@#ctime
    ==>
      (Ex secret pas2 #authstat. running(AuthSecret, actor, role, secret, <pas2, cas>)@#authstat & #authstat < #ctime) &
      (Ex secret cas2 #pauthstat. running(MutualAuthSecret, actor, role, secret, <pas, cas2>)@#pauthstat & #pauthstat < #ctime)"


lemma_matching_hsahs
lemma_matching_ahsms
lemma_matching_hsahsms
lemma_matching_ahsms_ms
lemma_matching_hsahsms_all

ifdef(<!POST_HS!>, <!
// For any running(PostHS...) either the auth_status was set in the main HS and
// unchanged (along with the RMS), or there was post-hs auth, which means the
// peer's auth_status is 'auth', the actor is a server*/
lemma_posths_rms/* [reuse, use_induction]:
  "All tid actor role hs rms peer auth_status messages #i. 
    running(PostHS, actor, role, hs, rms, peer, auth_status, messages)@i ==>
      Ex aas pas ms #j. 
                running(RMS, actor, role, peer, rms, messages)@j &
                ms = MasterSecret & rms = resumption_master_secret() & #j < #i &
                auth_status = <aas, pas> &
      (
        (Ex aas2 #k. commit(Identity, actor, role, peer, <aas2, pas>)@k & #k < #i) |
        (Ex aas2 #k. commit(IdentityPost, actor, role, peer, <aas2, pas>)@k &
                role = 'server' & pas = 'auth' & (#k < #i | #k = #i)
        )
      )"
*/

// A weakened version of the above lemma when needing to avoid the looping
// issue of the commit(IdentityPost, ...) bit.
// Can use [hide_lemma=posths_rms] to only use this version.
lemma_posths_rms_weak/* [reuse, use_induction]:
  "All tid actor role hs rms peer auth_status messages #i. 
    running(PostHS, actor, role, hs, rms, peer, auth_status, messages)@i ==>
      Ex aas pas ms #j. 
                running(RMS, actor, role, peer, rms, messages)@j &
                ms = MasterSecret & rms = resumption_master_secret() & #j < #i &
                auth_status = <aas, pas>"
*/
!>)


lemma matching_transcripts_posths [reuse, heuristic=s]:
  "All tid tid2 actor peer actor2 peer2 role role2 rms rms2 messages #i #j.
    running(RMS, actor, role, peer2, rms, messages)@i &
    running2(RMS, peer, role2, actor2, rms2, messages)@j & not (role = role2) ==>
     rms = rms2"

lemma matching_rms_posths [reuse, heuristic=c]:
  "All tid tid2 actor peer actor2 peer2 role role2 rms messages messages2 #i #j.
    running(RMS, actor, role, peer2, rms, messages)@i &
    running2(RMS, peer, role2, actor2, rms, messages2)@j & not (role = role2) ==>
     messages = messages2"

lemma matching_rms_actors [reuse, heuristic=i]:
  "All tid tid2 actor peer actor2 peer2 role rms messages messages2 #i #j.
    running(RMS, actor, role, peer, rms, messages)@i &
    running2(RMS, actor2, role, peer2, rms, messages2)@j ==>
     actor = actor2 & tid = tid2"

// takes 4-5 minutes to autoprove, but autoproves!
lemma matching_sessions [reuse, use_induction, heuristic=s, hide_lemma=posths_rms]:
  "All tid tid2 actor actor2 role role2 peer peer2 rms messages #i #j #k.
    running(RMS, actor, role, peer2, rms, messages)@i & 
    running2(RMS, peer, role2, actor2, rms, messages)@j &
    not (role = role2) &
    KU(rms)@k ==>
      (Ex #r. RevLtk(actor)@#r) |
      (Ex #r. RevLtk(peer)@#r)
      ifdef(<!PSK!>, <!
      |
      (Ex rms2 #r. RevealPSK(actor, rms2)@r & #r < #k) |
      (Ex rms2 #r. RevealPSK(peer, rms2)@r & #r < #k)
      !>)
      "

lemma auth_psk [reuse, use_induction, heuristic=c, hide_lemma=posths_rms_weak]:
  "All tid tid2 actor actor2 role role2 peer peer2 rms messages aas #i #j #k.
    running(RMS, actor, role, peer2, rms, messages)@i & 
    running2(RMS, peer, role2, actor2, rms, messages)@j &
    commit(Identity, actor, role, peer2, <aas, 'auth'>)@k &
    not (role = role2)
     ==>
      peer2 = peer |
      Ex #r. RevLtk(peer2)@r & #r < #k"


ifdef(<!POST_HS!>, <!
lemma_post_master_secret/* [reuse, hide_lemma=posths_rms]:
  "All tid actor peer role hs rms aas messages #i #k.
    running(PostHS, actor, role, hs, rms, peer, <aas, 'auth'>, messages)@i & 
    commit(HS, actor, role, hs)@i & 
    commit(IdentityPost, actor, role, peer, <aas, 'auth'>)@i &
    KU(rms)@k ==>
      (Ex #r. RevLtk(peer)@r & #r < #i) |
      (Ex tid3 x #r. RevDHExp(tid3, peer, x)@r & #r < #i) |
      (Ex tid4 y #r. RevDHExp(tid4, actor, y)@r & #r < #i) |
      (Ex rms2 #r. RevealPSK(actor, rms2)@r & #r < #k) |
      (Ex rms2 #r. RevealPSK(peer, rms2)@r & #r < #k)"
*/

lemma_invariant_post_hs/* [reuse, use_induction, hide_lemma=posths_rms]:
  "All tid actor peer peer2 role hs hs2 rms rms2 as as2 msgs msgs2 #i #j.
    running(PostHS, actor, role, hs, rms, peer, as, msgs)@i & 
    running(PostHS, actor, role, hs2, rms2, peer2, as2, msgs2)@j ==>
      peer = peer2 & rms = rms2 & msgs = msgs2 & hs = hs2"
*/
!>)

lemma matching_transcript_requires_matching_nonces [reuse]:
  "All tid tid2 actor peer transcript #i #ii.
    running(Transcript, actor, 'server', transcript)@#i &
    commit2(Transcript, peer, 'client', transcript)@#ii
    ==>
    Ex nonces #j #jj.
      commit(Nonces, actor, 'server', nonces)@#j & #j < #i &
      commit2(Nonces, peer, 'client', nonces)@#jj & #jj = #ii
  "

lemma cert_reception_matches_transcript [reuse,
      hide_lemma=authenticated_handshake_secret,
      hide_lemma=authenticated_handshake_secret_pfs,
      hide_lemma=kem_chal_dual,
      hide_lemma=entity_authentication,
      hide_lemma=mutual_entity_authentication,
      hide_lemma=injective_mutual_entity_authentication,
      hide_lemma=transcript_agreement,
      hide_lemma=mutual_transcript_agreement,
      hide_lemma=handshake_secret,
      hide_lemma=handshake_secret_pfs]:
  "All tid tid2 actor peer transcript #i #ii.
    running(Transcript, actor, 'server', transcript)@#i &
    commit2(Transcript, peer, 'client', transcript)@#ii
    ==>
      (Ex #sendcrt #recvcrt. C3_cert(tid2)@#sendcrt & S3_cert(tid)@#recvcrt & #sendcrt < #ii & #recvcrt < #i) |
      ((not Ex #sendcrt. C3_cert(tid2)@#sendcrt & #sendcrt < #ii) & not (Ex #recvcrt. S3_cert(tid)@#recvcrt & #recvcrt < #i))
  "

lemma auth_secret_consistency [reuse]:
  "All tid actor role aas pas secret #as.
    running(AuthSecret, actor, role, secret, <aas, pas>)@#as
    ==>
    (pas = '0' & secret = '0') |
    (pas = 'auth' & not (secret = '0'))"

lemma mutual_auth_secret_consistency [reuse]:
  "All tid actor role aas pas secret #as.
    running(MutualAuthSecret, actor, role, secret, <aas, pas>)@#as
    ==>
    (aas = '0' & secret = '0') |
    (aas = 'auth' & not (secret = '0'))"

// proves but not useful?
lemma auth_secret_ms_consistency [
    hide_lemma=kem_chal_dual]:
  "All tid actor role clauth_ss ms #t.
    running(MS, actor, role, clauth_ss, ms)@#t
    ==>
      (Ex auth_status #preauth. running(AuthSecret, actor, 'server', clauth_ss, auth_status)@#preauth & #preauth < #t) |
      (Ex auth_status #premutauth. running(MutualAuthSecret, actor, 'client', clauth_ss, auth_status)@#premutauth & #premutauth = #t)  
    " 

// autoproves but takes a while
lemma auth_implies_cert_was_sent_by_same_nonces [reuse,
    hide_lemma=kem_chal_dual]:
  "All tid tid2 actor peer aas nonces #t1 #t2.
    commit(Identity, actor, 'server', peer, <aas, 'auth'>)@#t1 &
    commit(Nonces, actor, 'server', nonces)@#t1 &
    commit2(Nonces, peer, 'client', nonces)@#t2
    ==>
      (Ex #recvcrt. S3_cert(tid)@#recvcrt & #recvcrt < #t1) & (
        (Ex #sendcert. C3_cert(tid2)@#sendcert & #sendcert < #t1) | 
        (Ex #revclcrt. RevLtk(peer)@#revclcrt)
      )"


lemma client_auth_means_clauth_ss_nonzero_client [reuse, 
    hide_lemma=authenticated_handshake_secret_server,
    hide_lemma=handshake_secret,
    hide_lemma=handshake_secret_pfs,
    hide_lemma=kem_chal_dual,
    hide_lemma=authenticated_handshake_secret,
    hide_lemma=entity_authentication,
    hide_lemma=mutual_entity_authentication,
    hide_lemma=injective_mutual_entity_authentication,
    hide_lemma=transcript_agreement,
    hide_lemma=mutual_transcript_agreement,
    hide_lemma=authenticated_handshake_secret_pfs,
    hide_lemma=ku_extract,
    hide_lemma=master_secret,
    hide_lemma=master_secret_pfs]:
  "All tid actor peer sas #cid.
    commit(Identity, actor, 'client', peer, <'auth', sas>)@#cid
    ==> 
    (Ex clauth_ss ms #runms. running(MS, actor, 'client', clauth_ss, ms)@#runms & #runms < #cid & not (clauth_ss = '0'))"


lemma client_auth_means_clauth_ss_nonzero_server [reuse,
    hide_lemma=authenticated_handshake_secret_server,
    hide_lemma=handshake_secret,
    hide_lemma=handshake_secret_pfs,
    hide_lemma=kem_chal_dual,
    hide_lemma=authenticated_handshake_secret,
    hide_lemma=entity_authentication,
    hide_lemma=mutual_entity_authentication,
    hide_lemma=injective_mutual_entity_authentication,
    hide_lemma=transcript_agreement,
    hide_lemma=mutual_transcript_agreement,
    hide_lemma=authenticated_handshake_secret_pfs,
    hide_lemma=ku_extract,
    hide_lemma=master_secret,
    hide_lemma=master_secret_pfs]:
  "All tid actor peer sas #cid.
    commit(Identity, actor, 'server', peer, <sas, 'auth'>)@#cid
    ==> 
    (Ex clauth_ss ms #runms. running(MS, actor, 'server', clauth_ss, ms)@#runms & #runms = #cid & not (clauth_ss = '0'))"