/*
If the adversary knows AHS or MS while we've commited to having authenticated the peer,
the adversary must have revealed Ltk and known HS before learning AHS.
(Possibly after committing, because they might reveal LTK after committing and used RevEKemSk to learn hs).

This last part is a change from the original model, which restricted RevLtk before commit.
*/

// To know the master secret for an authenticated peer, the peer's ltk
// must have been revealed. The ahs key needs to also be known, so either
// the adversary must impersonate the peer or it will have to stategically
// have done RevEKemSk.
lemma master_secret [reuse, use_induction, heuristic=cic]:
    "All tid actor role peer ahs ms aas #i #k.
        commit(AHS, actor, role, ahs)@#i &
        commit(MS, actor, role, ms)@#i &
        commit(Identity, actor, role, peer, <aas, 'auth'>)@#i &
        KU(ms)@k ==>
            (Ex #a. KU(ahs)@#a & #a < #k) &
            (Ex #r. RevLtk(peer)@#r & #r < #k)"

// to know the AHS key for an authenticated server, the
// server's ltk must've been revealed (to impersonate the server, because it needs to know HS as well).
lemma authenticated_handshake_secret_client [reuse, heuristic=cic]:
    "All tid actor peer hs ahs aas #i #k.
        commit(HS, actor, 'client', hs)@#i &
        commit(AHS, actor, 'client', ahs)@#i &
        commit(Identity, actor, 'client', peer, <aas, 'auth'>)@#i &
        KU(ahs)@k ==>
            (Ex #e. KU(hs)@#e & #e < #k) &
            (Ex #r. RevLtk(peer)@r & #r < #k)"

// to know the server's ahs for an authenticated client, the client's LTK must have
// been revealed (to impersonate the client, because it needs to know HS as well).
lemma authenticated_handshake_secret_server [reuse]:
    "All tid actor peer hs ahs aas #i #k.
        commit(HS, actor, 'server', hs)@#i &
        commit(AHS, actor, 'server', ahs)@#i &
        commit(Identity, actor, 'server', peer, <aas, 'auth'>)@#i &
        KU(ahs)@k ==>
            (Ex #e. KU(hs)@#e & #e < #k) &
            (Ex #r. RevLtk(peer)@r & #r < #k)"


// To learn the handshake secret in an authed connection, the adversary needs to
// either impersonate the peer (RevLtk), or reveal it.
lemma handshake_secret [reuse, use_induction, hide_lemma=posths_rms_weak, heuristic=i]:
  "All tid actor peer role hs aas #i #k.
    commit(HS, actor, role, hs)@i &
    commit(Identity, actor, role, peer, <aas, 'auth'>)@i &
    KU(hs)@k ==>
        (Ex #l. RevLtk(peer)@l & #l < #i) |                         dnl for impersonation
        (Ex tid3 esk #p. RevEKemSk(tid3, peer, esk)@p & #p < #i) |  dnl if the peer is client
        (Ex tid4 esk #r. RevEKemSk(tid4, actor, esk)@r & #r < #i) | dnl if the actor is client
        (Ex rms #r. RevealPSK(actor, rms)@r & #r < #k) |
        (Ex rms #r. RevealPSK(peer, rms)@r & #r < #k)"

// not really relevant unless we do resumption
lemma pfs_handshake_secret [reuse, hide_lemma=posths_rms_weak, heuristic=s]:
  "All tid actor peer role hs aas psk_ke_mode #i #k.
    commit(HS, actor, role, hs)@i &
    running(Mode, actor, role, psk_ke_mode)@i &
    commit(Identity, actor, role, peer, <aas, 'auth'>)@i &
    KU(hs)@k &
    (not psk_ke_mode = psk_ke) ==>
        (Ex #r. RevLtk(peer)@r & #r < #i) |
        (Ex tid3 esk #r. RevEKemSk(tid3, peer, esk)@r & #r < #i) |
        (Ex tid4 esk #r. RevEKemSk(tid4, actor, esk)@r & #r < #i) |
        (Ex rms #r. RevealPSK(actor, rms)@r & #r < #i) |
        (Ex rms #r. RevealPSK(peer, rms)@r & #r < #i)"