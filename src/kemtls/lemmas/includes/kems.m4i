/*******
  KEM LEMMAS
*/
// sanity check

lemma ekem_pk_can_be_decapsed:
  exists-trace
  "Ex tid a esk ekem ess #i #j.
     EKem(tid, a, esk)@#i
     & KemDecaps(ekem, esk, ess)@#j 
     & not (Ex #r. RevEKemSk(tid, a, esk)@#r & #r < #j)"

lemma ekem_sk_can_be_revealed:
  exists-trace
  "Ex tid a esk #i #j.
    EKem(tid, a, esk)@#i & RevEKemSk(tid, a, esk)@#j & #i < #j"

// unique 
lemma one_ekem_per_x [reuse, heuristic=C]:
  "All tid tid2 esk a a2 #i #j.
    EKem(tid, a, esk)@i & EKem(tid2, a2, esk)@j ==> 
      #i = #j & a = a2 & tid = tid2"


//NTS: RevDH < RRMS
//May have to add tid's to RevDH. 
// ordering
lemma ekem_rev_secret_ordering [reuse, heuristic=C]:
  "All esk tid a #i #j.
    RevEKemSk(tid, a, esk)@#i & EKem(tid, a, esk)@#j ==> #j < #i"

lemma ekem_only_revsk_in_client [reuse, heuristic=s]:
    "
    All tid a esk #i #j.
    EKem(tid, a, esk)@#i & RevEKemSk(tid, a, esk)@#j
    ==> (
      (Ex #r. Start(tid, a, 'client')@#r & #r < #j) & 
      not (Ex #r. Start(tid, a, 'server')@#r)
    )
    "

lemma rev_ekem_ordering  [reuse, use_induction, heuristic=C]:
  "All tid actor esk #j. 
    DelEKemSk(tid, actor, esk)@#j ==>
      ((Ex #i. EKem(tid, actor, esk)@#i & #i < #j) & 
       (All #r. RevEKemSk(tid, actor, esk)@#r  ==>  #r < #j))"

lemma rev_ekem_before_hs  [reuse, heuristic=I]:
  "All tid actor role hs esk #i #j.
    running(HS, actor, role, hs)@j &
    RevEKemSk(tid, actor, esk)@i ==>
    #i < #j"

lemma ku_encaps [reuse]:
  "All kem pk ss sk seed #i #j.
    KemEncap(kem, pk, ss)@#i &
    ss = <kem, seed> &
    pk = kempk(kem, sk) &
    KU(ss)@#j
    ==>
    (Ex #r. KU(seed)@r & #r < #j) |
    (Ex #r. KU(sk)@r & #r < #j)
  "

lemma ku_decaps [reuse]:
  "All kem sk ss seed #i #j.
    KemDecaps(kem, sk, ss)@#i &
    ss = <kem, seed> &
    KU(ss)@#j
    ==>
    (Ex #r. KU(seed)@#r & #r < #j) |
    (Ex #r. KU(sk)@#r & #r < #j)
  "

// requirements

lemma ekem_esk_can_only_be_revealed [reuse, heuristic=c]:
  "All tid a esk #i #j.
    (EKem(tid, a, esk)@#i & KU(esk)@#j) 
    ==> (Ex #r. RevEKemSk(tid, a, esk)@#r & #r < #j)"

lemma ekem_seed_needs_rev_esk [reuse, heuristic=i]:
    "All a tid ekem esk eseed #a #i #j.
    (EKem(tid, a, esk)@#a & KemEncap(ekem, kempk(ekem, esk), eseed)@#i & KU(eseed)@#j)
      ==> (Ex #r. RevEKemSk(tid, a, esk)@#r & #r < #j)"

lemma ekem_getting_seed_requires_esk [reuse, heuristic=i]:
  "All ekem esk eseed #i #j.
    (KemEncap(ekem, kempk(ekem, esk), eseed)@#i & KU(eseed)@#j)
    ==> 
    Ex #r. KU(esk)@#r & #r < #j"

// static KEM
lemma skem_getting_seed_requires_reveal [reuse, heuristic=i]:
  "All a kem ltk ss #a #i #j.
  (GenLtk(a, ltk)@#a & KemEncap(kem, kempk(kem, ltk), ss)@#i & KU(ss)@#j)
  ==>
  (Ex #r. RevLtk(a)@#r & #r < #j)"

// Ordering of the shared secret
lemma rev_kem_seed_ordering [reuse, heuristic=i]:
  "All kem pk ss #i #j. 
    KemEncap(kem, pk, ss)@i & KU(ss)@j ==> #i < #j"

lemma kem_consistency [reuse, heuristic=s]:
  "All kem pk ss #i.
    KemEncap(kem, pk, ss)@i
    ==>
      (Ex sk. pk = kempk(kem, sk)) &
      (Ex seed. ss = <kem, seed>)"

lemma kem_consistency_decaps [reuse, heuristic=s]:
  "All kem sk ss #i.
    KemDecaps(kem, sk, ss)@i
    ==>
      (Ex seed. ss = <kem, seed>)"

lemma kem_consistency_chal [reuse, heuristic=c]:
  "All kem sk pk ct ss #i.
    KemChal(kem, sk, pk, ct, ss)@#i
    ==>
      pk = kempk(kem, sk) &
      ct = kemencaps(kem, ss, pk) &
      (Ex seed. ss = <kem, seed>)"

lemma skem_consistency_chal [reuse, heuristic=c]:
  "All kem sk pk ct ss #i.
    SKemChal(kem, sk, pk, ct, ss)@#i
    ==>
      pk = kempk(kem, sk) &
      ct = kemencaps(kem, ss, pk) &
      (Ex seed. ss = <kem, seed>)"
    
lemma ckem_consistency_chal [reuse, heuristic=c]:
  "All kem sk pk ct ss #i.
    CKemChal(kem, sk, pk, ct, ss)@#i
    ==>
      pk = kempk(kem, sk) &
      ct = kemencaps(kem, ss, pk) &
      (Ex seed. ss = <kem, seed>)"

lemma kem_encaps_unique [reuse, heuristic=c]:
  "All kem pk ss #i #j.
    KemEncap(kem, pk, ss)@#i &
    KemEncap(kem, pk, ss)@#j
    ==>
    #i = #j"

// manually proves; guide it through as many kemencaps() operations as possible.
// oracle handles this for us.
lemma kem_encaps_ordering [reuse, heuristic=o "oracles/kem_encaps_ordering.py"]:
  "All kem pk sk ss #i #j.
    KemEncap(kem, pk, ss)@i &
    KemDecaps(kem, sk, ss)@j &
    pk = kempk(kem, sk)
    ==>
    #i < #j"

// this doesn't hold for static keys, as it's easy to
// make the decapsing party decaps the same ct twice by
// repeating the ciphertext
lemma kem_ephemeral_decaps_unique [reuse, heuristic=s]:
  "All tid a kem sk ss #k #i #j.
    EKem(tid, a, sk)@#k &
    KemDecaps(kem, sk, ss)@#i &
    KemDecaps(kem, sk, ss)@#j
    ==>
    #i = #j"

// chal_dual
lemma ekem_chal_dual [reuse, heuristic=c]:
  "All tid tid2 actor actor2 ekem esk epk ect ess #i #j #r.
    KemChal(ekem, esk, epk, ect, ess)@#i & Instance(tid, actor, 'client')@#i &
    KemChal(ekem, esk, epk, ect, ess)@#j & Instance(tid2, actor2, 'server')@#j &
    KU(ess)@#r
    ==>
    (Ex #p. (RevEKemSk(tid, actor, esk)@#p & #p < #r))"

// skem chal server
lemma kem_chal_dual_server_auth [reuse, heuristic=S]:
  "All tid tid2 actor actor2 kem sk pk ct ss #i #j #r.
    SKemChal(kem, sk, pk, ct, ss)@#i & Instance(tid, actor, 'client')@#i &
    SKemChal(kem, sk, pk, ct, ss)@#j & Instance(tid2, actor2, 'server')@#j &
    KU(ss)@#r
    ==>
    (Ex #k. RevLtk(actor2)@#k & #k < #r)"

lemma kem_chal_dual_client_auth [reuse, heuristic=c]:
  "All tid tid2 actor actor2 kem sk pk ct ss #i #j #r.
    CKemChal(kem, sk, pk, ct, ss)@#i & Instance(tid, actor, 'client')@#i &
    CKemChal(kem, sk, pk, ct, ss)@#j & Instance(tid2, actor2, 'server')@#j &
    KU(ss)@#r
    ==>
    (Ex #p. RevLtk(actor)@#p & #p < #r)"