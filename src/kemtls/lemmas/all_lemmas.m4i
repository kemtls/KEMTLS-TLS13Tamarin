define(<!uniq!>, <!
lemma one_$1_per_tid [reuse, heuristic=S]:
    "All tid #i #j. $1(tid)@i & $1(tid)@j ==> #i = #j"
!>)

define(<!one_of!>, <!
lemma $1_vs_$2 [reuse, heuristic=S]:
    "All tid #i #j. $1(tid)@i & $2(tid)@j ==> F"
!>)


define(<!lemma_tid_invariant!>, <!
lemma tid_invariant [use_induction, reuse, heuristic=S]:
  "All tid actor role #i. Instance(tid, actor, role)@i==>
      (Ex #j. Start(tid, actor, role)@j & (#j < #i))"
!>)

define(<!lemma_one_start_per_tid!>, <!
lemma one_start_per_tid [reuse, heuristic=SC]:
  "All tid actor actor2 role role2 #i #j. Start(tid, actor, role)@i & Start(tid, actor2, role2)@j ==>#i=#j"
!>)


/*
  TYPING LEMMAS
*/
define(<!lemma_cert_req_origin!>, <!
lemma cert_req_origin [sources]:
  "All certificate_request_context certificate_extensions keys #i.
    KU(senc{handshake_record('13', certificate_request_context, certificate_extensions)}keys)@i ==> 
      (Ex #j. KU(certificate_request_context)@j & #j < #i) |
      (Ex #j tid actor role. running(CertReqCtxt, actor, role, certificate_request_context)@j & #j < #i)"
!>)

define(<!lemma_nst_source!>, <!
lemma nst_source [sources]:
  "All ticket ticket_age_add tkt_lt tkt_exts app_key #i.
    KU(senc{handshake_record('4', tkt_lt, ticket_age_add, ticket, tkt_exts)}app_key)@i ==>
      (Ex #j #k. KU(ticket)@j & KU(ticket_age_add)@k & #j < #i & #k < #i) |
      (Ex tid S #j. running_server(NST, ticket, ticket_age_add)@j & #j < #i)"
!>)

define(<!lemma_ekem_source!>, <!
lemma ekem_source [sources]:
  "All tid esk actor #j.
    RevEKemSk(tid, actor, esk)@j 
    ==> 
      (Ex #i. EKem(tid, actor, esk)@i & #i < #j)"
!>)


ifdef(<!SIMPLE_MODEL!>, <!

define(<!lemma_cert_req_origin!>, <!
lemma cert_req_origin [sources]:
  "All certificate_request_context keys #i.
    KU(senc{<certificate_request_context>}keys)@i ==> 
      (Ex #j. KU(certificate_request_context)@j & #j < #i) |
      (Ex #j tid actor role. running(CertReqCtxt, actor, role, certificate_request_context)@j & #j < #i)"
!>)

define(<!lemma_nst_source!>, <!
lemma nst_source [sources]:
  "All ticket ticket_age_add tkt_exts app_key #i.
    KU(senc{<ticket_age_add, ticket, tkt_exts>}app_key)@i ==>
      (Ex #j #k. KU(ticket)@j & KU(ticket_age_add)@k & #j < #i & #k < #i) |
      (Ex tid S #j. running_server(NST, ticket, ticket_age_add)@j & #j < #i)"
!>)

!>)

ifdef(<!PSK!>, <!!>, <!
define(<!lemma_nst_source!>,<!!>)
!>)

/*
  LEMMAS USED IN AUTH_HELPERS
  
*/

define(<!lemma_matching_nonces!>, <!
lemma matching_nonces [reuse, heuristic=S]:
  "All tid tid2 actor actor2 role  nonces #i #j. 
    running(Nonces, actor, role, nonces)@i & 
    running2(Nonces, actor2, role, nonces)@j ==>
    tid = tid2 & actor = actor2"
!>)

define(<!lemma_consistent_nonces!>, <!
lemma consistent_nonces [reuse, heuristic=S]:
  "All tid actor role nonces #i. 
    commit(Nonces, actor, role, nonces)@i ==>
      Ex #j. running(Nonces, actor, role, nonces)@j"
!>)

define(<!lemma_invariant_nonces!>, <!
lemma invariant_nonces [reuse, heuristic=S]:
  "All tid actor actor2 role role2 nonces nonces2 #i #j.
    running(Nonces, actor, role, nonces)@i & 
    running(Nonces, actor2, role2, nonces2)@j ==> #i = #j"
!>)

define(<!lemma_matching_rms_nonces!>, <!
lemma matching_rms_nonces [reuse, heuristic=S]:
  "All nonces tid tid2 actor actor2 peer peer2 rms messages #i #j. 
    running(RMS, actor, 'client', peer, rms, messages)@i &
    running2(RMS, actor2, 'server', peer2, rms, messages)@j &
    commit2(Nonces, actor2, 'server', nonces)@j ==>
      Ex #a.
        commit(Nonces, actor, 'client', nonces)@a & 
        #a < #i"

!>)

/*
  LEMMAS USED IN SECRET_HELPERS

*/

define(<!lemma_ku_extract!>, <!
lemma ku_extract [reuse, use_induction]:
  "All a b #i. KU(Extract(a, b))@i ==> Ex #j #k. KU(a)@j & KU(b)@k & #j < #i & #k < #i"
!>)

define(<!lemma_ku_expand!>, <!
lemma ku_expand [reuse, use_induction]:
"All secret label len #i. KU(Expand(secret, label, len))@i ==>
  (Ex #j. KU(secret)@j & #j < #i) |
  (not (Ex #k. KU(secret)@k & #k < #i) &
  (Ex actor #l. RevealPSK(actor, Expand(secret, label, len))@l & #l < #i))"
!>)

<!/*
define(<!lemma_dh_chal_dual!>, <!
lemma dh_chal_dual [reuse]:
  "All tid tid2 actor actor2 g x y gx gy gxy #i #j #r.
      DHChal(g, x, y, gx, gy, gxy)@i & Instance(tid, actor, 'client')@i &
      DHChal(g, x, y, gx, gy, gxy)@j & Instance(tid2, actor2, 'server')@j &
      KU(gxy)@r 
      ==> 
      (Ex #p. (RevDHExp(tid, actor,  x)@p & #p < #r)) | 
      (Ex #q. (RevDHExp(tid2, actor2, y)@q & #q < #r))"
!>)
*/!>

dnl XXX: is this still the dual? Should we also include reveal of the shared secret at the server?
dnl XXX: Can this not be greatly simplified?
define(<!lemma_ekem_chal_dual!>, <!
lemma ekem_chal_dual [reuse]:
  "All tid tid2 actor actor2 ekem esk epk ect ess #i #j #r.
    KemChal(ekem, esk, epk, ect, ess)@#i & Instance(tid, actor, 'client')@#i &
    KemChal(ekem, esk, epk, ect, ess)@#j & Instance(tid2, actor2, 'server')@#j &
    KU(ess)@#r
    ==>
    (Ex #p. (RevEKemSk(tid, actor, esk)@#p & #p < #r))"
!>)

define(<!lemma_ku_hs!>, <!
lemma ku_hs [reuse]:
  "All tid actor role es hs res_psk ess #i #j.
    running(HS, actor, role, hs)@i &
    hs = HandshakeSecret &
    es = EarlySecret &
    KU(hs)@j ==>
      Ex #k #l. KU(ess)@k & KU(res_psk)@l & #k < #j & #l < #j"
!>)

define(<!lemma_ku_ahs!>, <!
lemma ku_ahs [reuse]:
  "All tid actor role ss hs ahs #i #j.
    running(AHS, actor, role, ahs)@i &
    ahs = AuthHandshakeSecret &
    KU(ahs)@j  ==>
      Ex #k #l. KU(hs)@k & KU(ss)@l & #k < #j & #l < #j" 
!>)

define(<!lemma_ku_ms!>, <!
lemma ku_ms [reuse]:
  "All tid actor role ms ahs clauth_ss #i #j.
    running(MS, actor, role, ms)@i &
    ms = MasterSecret &
    KU(ms)@j ==>
      Ex #k #l. KU(ahs)@k & KU(clauth_ss)@l & #k < #j & #l < #j" 
!>)

define(<!lemma_ku_ltk!>, <!
lemma ku_ltk [reuse]:
  "All actor ltkA #i #j.
    GenLtk(actor, ltkA)@i & KU(ltkA)@j ==>
      Ex #k. RevLtk(actor)@k & #k < #j"
!>)

define(<!lemma_ku_fresh_psk!>, <!
lemma ku_fresh_psk [reuse]:
  "All ticket res_psk #i #k.
      FreshPSK(ticket,res_psk)@i & KU(res_psk)@k ==> 
        Ex actor #j. 
          RevealPSK(actor, res_psk)@j & #j < #k"
!>)

define(<!lemma_hsahs_derive!>, <!
lemma hsahs_derive [reuse]:
  "All tid actor role hs ahs ss #i.
    running(HSAHS, actor, role, hs, ahs, ss)@#i ==>
      ahs = AuthHandshakeSecret
  "
!>)

define(<!lemma_ahsms_derive!>, <!
lemma ahsms_derive [reuse]:
  "All tid actor role ahs ms clauth_ss #i. 
    running(AHSMS, actor, role, ahs, ms, clauth_ss)@i ==>
      ms = MasterSecret"
!>)

define(<!lemma_ku_rms!>, <!
lemma ku_rms [reuse]:
  "All tid actor role peer rms messages ms #i #j.
    running(RMS, actor, role, peer, rms, messages)@i &
    rms = resumption_master_secret() &
    KU(rms)@j ==>
      Ex #k #l. KU(ms)@k & KU(messages)@l & #k < #j & #l < #j"
!>)

define(<!lemma_posths_rms_weak!>, <!
// For any running(PostHS...) either the auth_status was set in the main HS and
// unchanged (along with the RMS), or there was post-hs auth, which means the
// peer's auth_status is 'auth', the actor is a server
lemma posths_rms_weak [reuse, use_induction]:
  "All tid actor role hs rms peer auth_status messages #i. 
    running(PostHS, actor, role, hs, rms, peer, auth_status, messages)@i ==>
      Ex aas pas ms #j. 
                running(RMS, actor, role, peer, rms, messages)@j &
                ms = MasterSecret & rms = resumption_master_secret() & #j < #i &
                auth_status = <aas, pas>"
!>)


define(<!lemma_posths_rms!>, <!
// For any running(PostHS...) either the auth_status was set in the main HS and
// unchanged (along with the RMS), or there was post-hs auth, which means the
// peer's auth_status is 'auth', the actor is a server
lemma posths_rms [reuse, use_induction]:
  "All tid actor role hs rms peer auth_status messages #i. 
    running(PostHS, actor, role, hs, rms, peer, auth_status, messages)@i ==>
      Ex aas pas ms #j. 
                running(RMS, actor, role, peer, rms, messages)@j &
                ms = MasterSecret & rms = resumption_master_secret() & #j < #i &
                auth_status = <aas, pas> &
      (
        (Ex aas2 #k. commit(Identity, actor, role, peer, <aas2, pas>)@k & #k < #i) |
        (Ex aas2 #k. commit(IdentityPost, actor, role, peer, <aas2, pas>)@k &
                role = 'server' & pas = 'auth' & (#k < #i | #k = #i)
        )
      )"
!>)

define(<!lemma_matching_transcripts_posths!>, <!
lemma matching_transcripts_posths [reuse]:
  "All tid tid2 actor peer actor2 peer2 role role2 rms rms2 messages #i #j.
    running(RMS, actor, role, peer2, rms, messages)@i &
    running2(RMS, peer, role2, actor2, rms2, messages)@j & not (role = role2) ==>
     rms = rms2"
!>)

define(<!lemma_matching_rms_posths!>, <!
lemma matching_rms_posths [reuse]:
  "All tid tid2 actor peer actor2 peer2 role role2 rms messages messages2 #i #j.
    running(RMS, actor, role, peer2, rms, messages)@i &
    running2(RMS, peer, role2, actor2, rms, messages2)@j & not (role = role2) ==>
     messages = messages2"
!>)

define(<!lemma_matching_rms_actors!>, <!
lemma matching_rms_actors [reuse]:
  "All tid tid2 actor peer actor2 peer2 role rms messages messages2 #i #j.
    running(RMS, actor, role, peer, rms, messages)@i &
    running2(RMS, actor2, role, peer2, rms, messages2)@j ==>
     actor = actor2 & tid = tid2"
!>)

define(<!lemma_matching_sessions!>, <!
lemma matching_sessions [reuse, use_induction, hide_lemma=posths_rms]:
  "All tid tid2 actor actor2 role role2 peer peer2 rms messages #i #j #k.
    running(RMS, actor, role, peer2, rms, messages)@i & 
    running2(RMS, peer, role2, actor2, rms, messages)@j &
    not (role = role2) &
    KU(rms)@k ==>
      (Ex tid3 esk #r. RevEKemSk(tid3, actor, esk)@r & #r < #i) |
      (Ex tid4 esk #r. RevEKemSk(tid4, peer, esk)@r & #r < #j) |
      (Ex rms2 #r. RevealPSK(actor, rms2)@r & #r < #k) |
      (Ex rms2 #r. RevealPSK(peer, rms2)@r & #r < #k)"
!>)

define(<!lemma_auth_psk!>, <!
lemma auth_psk [reuse, use_induction, hide_lemma=posths_rms_weak]:
  "All tid tid2 actor actor2 role role2 peer peer2 rms messages aas #i #j #k.
    running(RMS, actor, role, peer2, rms, messages)@i & 
    running2(RMS, peer, role2, actor2, rms, messages)@j &
    commit(Identity, actor, role, peer2, <aas, 'auth'>)@k &
    not (role = role2)
     ==>
      peer2 = peer |
      Ex #r. RevLtk(peer2)@r & #r < #k"
!>)

define(<!lemma_matching_hsahsms!>, <!
lemma matching_hsahsms [reuse]:
  "All tid actor role hs hs2 ahs ms #i #j.
    commit(HS, actor, role, hs2)@i &
    running(HSAHSMS, actor, role, hs, ahs, ms)@j ==>
      hs = hs2"
!>)

define(<!lemma_matching_hsahs!>, <!
lemma matching_hsahs [reuse]:
  "All tid actor role hs hs2 ahs ss #i #j.
    commit(HS, actor, role, hs2)@i &
    running(HSAHS, actor, role, hs, ahs, ss)@j ==>
      hs = hs2"
!>)

define(<!lemma_matching_ahsms!>, <!
lemma matching_ahsms [reuse]:
  "All tid actor role ahs ahs2 ms clauth_ss #i #j.
    commit(AHS, actor, role, ahs2)@i &
    running(AHSMS, actor, role, ahs, ms, clauth_ss)@j ==>
      ahs = ahs2"
!>)

define(<!lemma_matching_hsahsms_all!>, <!
lemma matching_hsahsms_all [reuse]:
  "All tid actor role hs hs2 ahs ahs2 ms ms2 clauth_ss #i #j #k #l.
    commit(HS, actor, role, hs2)@i &
    commit(AHS, actor, role, ahs2)@j &
    commit(MS, actor, role, ms2)@k &
    running(HSAHSMS, actor, role, hs, ahs, ms, clauth_ss)@l ==>
      (hs = hs2 & ahs = ahs2 & ms = ms2)"
!>)

define(<!lemma_matching_ahsms_ms!>, <!
lemma matching_ahsms_ms [reuse]:
  "All tid actor role ahs ms ms2 clauth_ss #i #j.
    commit(MS, actor, role, ms2)@i &
    running(AHSMS, actor, role, ahs, ms, clauth_ss)@j ==>
      ms = ms2"
!>)


define(<!lemma_post_master_secret!>, <!
lemma post_master_secret [reuse, hide_lemma=posths_rms]:
  "All tid actor peer role hs rms aas messages #i #k.
    running(PostHS, actor, role, hs, rms, peer, <aas, 'auth'>, messages)@i & 
    commit(HS, actor, role, hs)@i & 
    commit(IdentityPost, actor, role, peer, <aas, 'auth'>)@i &
    KU(rms)@k ==>
      (Ex #r. RevLtk(peer)@r & #r < #i) |
      (Ex tid3 esk #r. RevEKemSk(tid3, peer, esk)@r & #r < #i) |
      (Ex tid4 esk #r. RevEKemSk(tid4, actor, esk)@r & #r < #i) |
      (Ex rms2 #r. RevealPSK(actor, rms2)@r & #r < #k) |
      (Ex rms2 #r. RevealPSK(peer, rms2)@r & #r < #k)"
!>)

define(<!lemma_invariant_post_hs!>, <!
lemma invariant_post_hs [reuse, use_induction, hide_lemma=posths_rms]:
  "All tid actor peer peer2 role hs hs2 rms rms2 as as2 msgs msgs2 #i #j.
    running(PostHS, actor, role, hs, rms, peer, as, msgs)@i & 
    running(PostHS, actor, role, hs2, rms2, peer2, as2, msgs2)@j ==>
      peer = peer2 & rms = rms2 & msgs = msgs2 & hs = hs2"
!>)

define(<!lemma_handshake_secret!>, <!
lemma handshake_secret [reuse, use_induction, hide_lemma=posths_rms_weak]:
  "All tid actor peer role hs aas #i #k.
    commit(HS, actor, role, hs)@i &
    commit(Identity, actor, role, peer, <aas, 'auth'>)@i &
    KU(hs)@k ==>
        (Ex #r. RevLtk(peer)@r & #r < #i) |
        (Ex tid3 esk #r. RevEKemSk(tid3, peer, esk)@r & #r < #i) |
        (Ex tid4 esk #r. RevEKemSk(tid4, actor, esk)@r & #r < #i) |  dnl is actor the client here?
        (Ex rms #r. RevealPSK(actor, rms)@r & #r < #k) |
        (Ex rms #r. RevealPSK(peer, rms)@r & #r < #k)"
!>)

define(<!lemma_pfs_handshake_secret!>, <!
lemma pfs_handshake_secret [reuse, hide_lemma=posths_rms_weak]:
  "All tid actor peer role hs aas psk_ke_mode #i #k.
    commit(HS, actor, role, hs)@i &
    running(Mode, actor, role, psk_ke_mode)@i &
    commit(Identity, actor, role, peer, <aas, 'auth'>)@i &
    KU(hs)@k &
    (not psk_ke_mode = psk_ke) ==>
        (Ex #r. RevLtk(peer)@r & #r < #i) |
        (Ex tid3 esk #r. RevEKemSk(tid3, peer, esk)@r & #r < #i) |
        (Ex tid4 esk #r. RevEKemSk(tid4, actor, esk)@r & #r < #i) |
        (Ex rms #r. RevealPSK(actor, rms)@r & #r < #i) |
        (Ex rms #r. RevealPSK(peer, rms)@r & #r < #i)"
!>)

/*
  LEMMAS USED IN LEMMA

*/
define(<!lemma_secret_session_keys!>, <!
lemma secret_session_keys [hide_lemma=sig_origin,hide_lemma=posths_rms]:
  "All tid actor peer kw kr pas #i.
      SessionKey(tid, actor, peer, <pas, 'auth'>, <kw, kr>)@i & 
      not (Ex #r. RevLtk(peer)@r & #r < #i) &
      not (Ex tid3 esk #r. RevEKemSk(tid3, peer, esk)@r & #r < #i) &
      not (Ex tid4 esk #r. RevEKemSk(tid4, actor, esk)@r & #r < #i) &
      not (Ex rms #r. RevealPSK(actor, rms)@r) &
      not (Ex rms #r. RevealPSK(peer, rms)@r)
    ==> not Ex #j. K(kr)@j"
!>)

define(<!lemma_secret_session_keys_pfs!>, <!
lemma secret_session_keys_pfs [hide_lemma=sig_origin,hide_lemma=posths_rms]:
  "All tid actor peer role kw kr pas psk_ke_mode #i.
      SessionKey(tid, actor, peer, <pas, 'auth'>, <kw, kr>)@i & 
      running(Mode, actor, role, psk_ke_mode)@i &
      not (Ex #r. RevLtk(peer)@r & #r < #i) &
      not (Ex tid3 esk #r. RevEKemSk(tid3, peer, esk)@r & #r < #i) &
      not (Ex tid4 esk #r. RevEKemSk(tid4, actor, esk)@r & #r < #i) &
      not (Ex rms #r. RevealPSK(actor, rms)@r & #r < #i) &
      not (Ex rms #r. RevealPSK(peer, rms)@r & #r < #i) &
      not (psk_ke_mode = psk_ke)
    ==> not Ex #j. K(kr)@j"
!>)

define(<!lemma_session_key_agreement!>, <!
lemma session_key_agreement [hide_lemma=sig_origin]:
  "All tid tid2 actor peer actor2 peer2 nonces keys keys2 cas as2 #i #j #k #l.
     SessionKey(tid, actor, peer2, <cas, 'auth'>, keys)@i & 
     running(Nonces, actor, 'client', nonces)@j &
     SessionKey(tid2, peer, actor2, as2, keys2)@k &
     running2(Nonces, peer, 'server', nonces)@l &
      // not (Ex #r. RevLtk(actor)@r & #r < #i) &
      not (Ex #r. RevLtk(peer)@r & #r < #i & #r < #k) &
      not (Ex tid3 esk #r. RevEKemSk(tid3, actor, esk)@r & #r < #i & #r < #k) &
      not (Ex rms #r. RevealPSK(actor, rms)@r & #r < #i & #r < #k) &
      not (Ex rms #r. RevealPSK(peer, rms)@r & #r < #i & #r < #k)
      ==>
       keys = keys2"
!>)

define(<!lemma_unique_session_keys!>, <!
lemma unique_session_keys:
  "All tid tid2 actor peer peer2 kr kw as as2 #i #j.
     SessionKey(tid, actor, peer, as, <kr, kw>)@i & 
     SessionKey(tid2, actor, peer2, as2, <kr, kw>)@j
      ==>
        #i = #j"
!>)

define(<!lemma_entity_authentication!>, <!
/*
  Unilateral (entity) authentication
*/
lemma entity_authentication [reuse, use_induction]:
  "All tid actor peer nonces cas #i. 
      commit(Nonces, actor, 'client', nonces)@i & commit(Identity, actor, 'client', peer, <cas, 'auth'>)@i &
      not (Ex #r. RevLtk(peer)@r & #r < #i) &
      not (Ex tid3 esk #r. RevEKemSk(tid3, actor, esk)@r & #r < #i) &
      not (Ex rms #r. RevealPSK(actor, rms)@r) &
      not (Ex rms #r. RevealPSK(peer, rms)@r)
          ==> (Ex tid2 #j. running2(Nonces, peer, 'server', nonces)@j & #j < #i)"
!>)

define(<!lemma_transcript_agreement!>, <!
/*
  Integrity of handshake messages
*/
lemma transcript_agreement [reuse]:
  "All tid actor peer transcript cas #i.
      commit(Transcript, actor, 'client', transcript)@i & commit(Identity, actor, 'client', peer, <cas, 'auth'>)@i &
      not (Ex #r. RevLtk(peer)@r & #r < #i) &
      not (Ex tid3 esk #r. RevEKemSk(tid3, actor, esk)@r & #r < #i) &
      not (Ex rms #r. RevealPSK(actor, rms)@r) &
      not (Ex rms #r. RevealPSK(peer, rms)@r)
          ==> (Ex tid2 #j. running2(Transcript, peer, 'server', transcript)@j & #j < #i)"
!>)

define(<!lemma_mutual_entity_authentication!>, <!
/*
  Mutual (entity) authentication
*/
lemma mutual_entity_authentication [reuse, use_induction]:
  "All tid actor peer nonces sas #i.
      commit(Nonces, actor, 'server', nonces)@i & commit(Identity, actor, 'server', peer, <sas, 'auth'>)@i &
      not (Ex #r. RevLtk(peer)@r & #r < #i) &
      not (Ex tid3 esk #r. RevEKemSk(tid3, peer, esk)@r & #r < #i) &
      not (Ex rms #r. RevealPSK(actor, rms)@r) &
      not (Ex rms #r. RevealPSK(peer, rms)@r)
          ==> (Ex tid2 #j. running2(Nonces, peer, 'client', nonces)@j & #j < #i)"
!>)

define(<!lemma_mutual_transcript_agreement!>, <!
/*
  Integrity of handshake messages
*/
lemma mutual_transcript_agreement [reuse]:
  "All tid actor transcript peer sas #i.
      commit(Transcript, actor, 'server', transcript)@i & commit(Identity, actor, 'server', peer, <sas, 'auth'>)@i & 
      not (Ex #r. RevLtk(peer)@r & #r < #i) &
      not (Ex tid3 esk #r. RevEKemSk(tid3, peer, esk)@r & #r < #i) &
      not (Ex rms #r. RevealPSK(actor, rms)@r) &
      not (Ex rms #r. RevealPSK(peer, rms)@r)
          ==> (Ex tid2 #j. running2(Transcript, peer, 'client', transcript)@j & #j < #i)"
!>)


define(<!lemma_mutual_injective_entity_authentication!>, <!
/*
  Mutual (entity) authentication
*/
lemma injective_mutual_entity_authentication [reuse, hide_lemma=posths_rms]:
  "All tid actor peer role nonces aas #i.
      commit(Nonces, actor, role, nonces)@i & commit(Identity, actor, role, peer, <aas, 'auth'>)@i &
      not (Ex #r. RevLtk(peer)@r & #r < #i) &
      not (Ex tid3 esk #r. RevEKemSk(tid3, peer, esk)@r & #r < #i) &
      not (Ex tid4 esk #r. RevEKemSk(tid4, actor, esk)@r & #r < #i) &
      not (Ex rms #r. RevealPSK(actor, rms)@r) &
      not (Ex rms #r. RevealPSK(peer, rms)@r)
          ==> 
          Ex role2 tid2 #j. running2(Nonces, peer, role2, nonces)@j & #j < #i & not role = role2 &
          (All tid3 peer2 #k. running3(Nonces, peer2, role2, nonces)@k ==> #k = #j)"
!>)

/*
  LEMMAS USED IN KEM_INJ

*/

define(<!lemma_ekem_sk_invariant!>, <!
lemma ekem_sk_invariant  [use_induction, reuse, heuristic=C]:
  "All tid actor esk #i. 
    RevEKemSk(tid, actor, esk)@#i ==> Ex #j. EKem(tid, actor, esk)@#j & #j < #i"
!>)

define(<!lemma_ekem_sk_secret_ordering!>, <!
lemma ekem_rev_secret_ordering [reuse, heuristic=s]:
  "All esk tid a #i #j.
    RevEKemSk(tid, a, esk)@#i & EKem(tid, a, esk)@#j ==> #j < #i"
!>)

define(<!lemma_rev_ekem_ordering!>, <!
lemma rev_ekem_ordering  [reuse, use_induction, heuristic=C]:
  "All tid actor esk #j. 
    DelEKemSk(tid, actor, esk)@#j ==>
      ((Ex #i. EKem(tid, actor, esk)@#i & #i < #j) & 
       (All #r. RevEKemSk(tid, actor, esk)@#r  ==>  #r < #j))"
!>)

define(<!lemma_rev_ekem_before_hs!>, <!
lemma rev_ekem_before_hs  [reuse, heuristic=I]:
  "All tid actor role hs esk #i #j.
    running(HS, actor, role, hs)@j &
    RevEKemSk(tid, actor, esk)@i ==>
    #i < #j"
!>)
//NTS: RevDH < RRMS
//May have to add tid's to RevDH. 

define(<!lemma_one_ekem_per_x!>, <!
lemma one_ekem_per_x [reuse, heuristic=C]:
  "All tid tid2 esk a a2 #i #j.
    EKem(tid, a, esk)@i & EKem(tid2, a2, esk)@j ==> #i = #j"
!>)

// this lemma helps us show that decaps/encaps works
define(<!lemma_ekem_pk_can_be_decapsed!>,<!
lemma ekem_pk_can_be_decapsed:
  exists-trace
  "Ex tid a esk ekem ess #i #j.
     EKem(tid, a, esk)@#i
     & KemDecaps(ekem, esk, ess)@#j 
     & not (Ex #r. RevEKemSk(tid, a, esk)@#r & #r < #j)"
!>)

define(<!lemma_ekem_sk_can_be_revealed!>,<!
lemma ekem_sk_can_be_revealed:
  exists-trace
  "Ex tid a esk #i #j.
    EKem(tid, a, esk)@#i & RevEKemSk(tid, a, esk)@#j & #i < #j"
!>)

define(<!lemma_ekem_esk_can_only_be_revealed!>,<!
lemma ekem_esk_can_only_be_revealed [reuse]:
  "All tid a esk #i #j.
    (EKem(tid, a, esk)@#i & KU(esk)@#j) 
    ==> (Ex #r. RevEKemSk(tid, a, esk)@#r & #r < #j)"
!>)

define(<!lemma_ekem_seed_needs_rev_esk!>, <!
lemma ekem_seed_needs_rev_esk [reuse]:
    "All a tid ekem esk eseed #a #i #j.
    (EKem(tid, a, esk)@#a & KemEncap(ekem, kempk(ekem, esk), eseed)@#i & KU(eseed)@#j)
      ==> (Ex #r. RevEKemSk(tid, a, esk)@#r & #r < #j)"
!>)

define(<!lemma_ekem_getting_seed_requires_esk!>, <!
lemma ekem_getting_seed_requires_esk [reuse]:
  "All ekem esk eseed #i #j.
    (KemEncap(ekem, kempk(ekem, esk), eseed)@#i & KU(eseed)@#j)
    ==> 
    Ex #r. KU(esk)@#r & #r < #j"
!>)

define(<!lemma_ekem_only_revsk_in_client!>, <!
lemma ekem_only_revsk_in_client [reuse]:
    "
    All tid a esk #i #j.
    EKem(tid, a, esk)@#i & RevEKemSk(tid, a, esk)@#j
    ==> (
      (Ex #r. Start(tid, a, 'client')@#r & #r < #j) & 
      not (Ex #r. Start(tid, a, 'server')@#r)
    )
    "
!>)