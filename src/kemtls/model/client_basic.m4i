dnl(
/*
  Client rules for standard (vanilla) handshake.

  From the specification 2. Protocol overview

         Client                                               Server

  Key  ^ ClientHello
  Exch | + key_share*
       v + pre_shared_key*         -------->
                                                         ServerHello  ^ Key
                                                        + key_share*  | Exch
                                                   + pre_shared_key*  v
                                               {EncryptedExtensions}  ^  Server
                                               {CertificateRequest*}  v  Params
                                                      {Certificate*}  ^
                                                                      | Auth
         {KemEncapsulation}        -------->                          |
       ^ <Certificate*>                                               |
         <Finished>                -------->                          |
         [Application Data*]       -------->                          |
                                                 <KemEncapsulation*>  |
                                                          [Finished]  v
                                   <--------     [Application Data*]
       v {Finished}                -------->
*/)

dnl Extensions definitions for basic ClientHello
define(<!ClientHelloExtensions!>, <!<SupportedVersions, NamedGroupList, SignatureSchemeList, KeyShareCH >!>)
rule client_hello:
let
    // Initialise state variables to zero.
    init_state()

    // Abstract client identity - does not currently correspond to
    // anything concrete
    C = $C

    // Server identity - can be interpreted as the hostname
    S = $S

    // Client nonce
    nc = ~nc

    // We reuse the client nonce to be a thread identifier
    tid = nc

    // Group=kem alg, KEM private key, key share
    // this has some legacy from when this was based on dh
    k1 = $k1
    k2 = $k2
    sekem = <k1, k2>
    client_sekem = <k1, k2>
    ekem = k1
    esk = ~esk
    epk = kempk(ekem, esk)

    messages = <messages, ClientHello>
    es = EarlySecret
in
    [ Fr(nc),
      Fr(esk)
    ]
  --[ C0(tid),
      Start(tid, C, 'client'),
      running_client(Identity, C),
      Neq(k1, k2),
      EKem(tid, C, esk),
      HonestUse(~esk),
      HonestUse(epk)
    ]->
    [
      State(C1, tid, C, S, ClientState),
      EKemSk(esk, tid, C),
      // Write the ClientHelloMsg onto the wire *presumably* with destination S
      Out(ClientHello)
    ]

define(<!HelloRetryRequestExtensions!>, <!<KeyShareHRR>!>)
rule recv_hello_retry_request:
let
    k1 = $k1
    k2 = $k2
    prev_sekem = <k1, k2>
    prev_ekem = k1
    prev_hrr = '0'
    set_state()
    hrr = 'hrr'
    new_ekem = k2
    ekem = k2
    client_sekem = <k1, k2>

    C = $C
    S = $S

    new_esk = ~new_esk
    esk = new_esk
    epk = kempk(ekem, esk)


    // PSK after HRR has its own rule (see recv_hello_retry_request_psk)
    psk_ke_mode = 'na'
    auth_status = <'0', '0'>

    messages = <messages, HelloRetryRequest>
    messages = <messages, ClientHello>
    es = EarlySecret
in
    [ State(C1, tid, C, S, PrevClientState),
      Fr(new_esk),
      In(HelloRetryRequest),
      EKemSk(prev_esk, tid, C)
    ]
  --[ C1_retry(tid),
      Neq(k1, k2),
      Instance(tid, C, 'client'),
      DelEKemSk(tid, C, prev_esk),
      EKem(tid, C, esk)
    ]->
    [ Out(ClientHello),
      EKemSk(esk, tid, C),
      State(C1, tid, C, S, ClientState)
    ]


dnl Extensions definitions for basic ServerHello
define(<!ServerHelloExtensions!>, <!<SignatureSchemeList, KeyShareSH>!>)
rule recv_server_hello:
let
    prev_ekem = $k1
    prev_esk = ~esk

    set_state()
    ns = new_ns
    ect = new_ect

    C = $C
    S = $S

    // equivalent to checking kempk in <$ekem>
    // pattern matches through In(SH)
    ect = kemencaps(ekem, <ekem, new_eseed>, epk)

    // Derive the shared secret
    ess = kemdecaps(ekem, ect, esk)

    // Received a basic server hello - abandon PSK mode (if attempted)
    psk_ke_mode = 'na'
    auth_status = <'0', '0'>

    messages = <messages, ServerHello>
in
    [ State(C1, tid, C, S, PrevClientState)[no_precomp],
      In(ServerHello)
    ]
  --[ C1(tid),
      Instance(tid, C, 'client'),
      KemChal(ekem, esk, epk, ect, ess),
      KemDecaps(ekem, esk, ess),
      running_client(Nonces, nc, ns)
    ]->
    [
      State(C2a, tid, C, S, ClientState)
    ]

rule client_gen_keys:
let
    set_state()

    C = $C
    S = $S

    hs = HandshakeSecret

    hs_keyc = keygen(handshake_traffic_secret(client), hs_key_label())
    hs_keys = keygen(handshake_traffic_secret(server), hs_key_label())

in
    [ State(C2a, tid, C, S, PrevClientState)[no_precomp],
      EKemSk(esk, tid, C)
    ]
  --[ C2a(tid),
      Instance(tid, C, 'client'),
      running_client(HS, hs),
      DelEKemSk(tid, C, esk)  dnl models that the ephemeral key is thrown away here.
    ]->
    [
      State(C2b, tid, C, S, ClientState)
    ]

rule recv_encrypted_extensions:
let
    set_state()

    S = $S
    C = $C

    messages = <messages, EncryptedExtensions>

in
    [ State(C2b, tid, C, S, PrevClientState)[no_precomp],
      In(senc{EncryptedExtensions}hs_keys)
    ]
  --[ C2b(tid),
      Instance(tid, C, 'client')
    ]->
    [ State(C2c, tid, C, S, ClientState)
    ]

rule recv_certificate_request:
let
    prev_psk_ke_mode ='na'
    set_state()

    S = $S
    C = $C

    certificate_request_context = '0' 
    cert_req = '1'
    messages = <messages, CertificateRequest>

in
    [ State(C2c, tid, C, S, PrevClientState)[no_precomp],
      In(senc{CertificateRequest}hs_keys)
    ]
  --[ C2c_req(tid),
      Instance(tid, C, 'client')
    ]->
    [ State(C2d, tid, C, S, ClientState)
    ]

rule skip_recv_certificate_request:
let
    set_state()

    S = $S
    C = $C
    cert_req = '0'
in
    [ State(C2c, tid, C, S, PrevClientState)[no_precomp]
    ]
  --[ C2c(tid),
      Instance(tid, C, 'client')
    ]->
    [ State(C2d, tid, C, S, ClientState)
    ]

rule recv_server_cert_emit_kex:
let
  prev_psk_ke_mode = 'na'
  set_state()

  S = $S
  C = $C

  certificate_request_context = '0'
  certificate = kempk($k, ~ltkS)
  
  messages = <messages, Certificate>
  
  ss = <$k, ~seed>
  ciphertext = kemencaps($k, ss, certificate)

  messages = <messages, KemEncapsulation>

  ahs = AuthHandshakeSecret

  ahs_keyc = keygen(authenticated_handshake_traffic_secret(client), ahs_key_label())
  ahs_keys = keygen(authenticated_handshake_traffic_secret(server), ahs_key_label())

  // we've now authenticated the server
  auth_status = <'0', 'auth'>

in
  [
    State(C2d, tid, C, S, PrevClientState)[no_precomp],
    !Pk(S, kempk($k, ~ltkS)),
    Fr(~seed),
    In(senc{Certificate}hs_keys)
  ]
  --[
    C2d(tid),
    Instance(tid, C, 'client'),
    Eq(psk_ke_mode, 'na'),
    running_client(HSAHS, hs, ahs, ss),
    running_client(AHS, ahs),
    running_client(Mode, psk_ke_mode),
    KemEncap($k, certificate, ss)
  ]->
  [
    State(C3, tid, C, S, ClientState),
    Out(senc{KemEncapsulation}hs_keyc)
  ]

rule client_auth:
let
    // If certificate was requested, cannot ignore
    prev_cert_req = '0'
    set_state()

    S = $S
    C = $C

    verify_data = compute_finished(client)

    messages = <messages, Finished>

    ms = MasterSecret
    rms = resumption_master_secret()

    app_keyc = keygen(cats, app_key_label())
    //app_keys = keygen(sats, app_key_label())
in

    [ State(C3, tid, C, S, PrevClientState)[no_precomp]
    ]
  --[ C3_skip_cert(tid),
      Instance(tid, C, 'client'),
      running_client(Transcript, messages),
      running_client(MS, clauth_ss, ms),
      running_client(AHSMS, ahs, ms, clauth_ss),
      running_client(HSAHSMS, hs, ahs, ms),
      running_client(RMS, S, rms, messages),
      running_client(Mode, psk_ke_mode)
    ]->
    [ State(C3b, tid, C, S, ClientState),
      Out(senc{Finished}ahs_keyc),
      SendStream(tid, C, S, auth_status, app_keyc)
    ]

rule client_send_cert:
let
    prev_cert_req = '1'
    prev_psk_ke_mode = 'na'
    set_state()

    S = $S
    C = $C

    certificate_request_context = '0'
    certificate = kempk($k, ~ltkC)
    messages = <messages, Certificate>
in
  [
    State(C3, tid, C, S, PrevClientState)[no_precomp],
    !Ltk(C, ~ltkC)
  ]
  --[
    C3_cert(tid),
    Instance(tid, C, 'client')
  ]->
  [
    State(C3a, tid, C, S, ClientState),
    Out(senc{Certificate}ahs_keyc)
  ]

rule client_recv_encaps:
let
    set_state()

    S = $S
    C = $C


    ciphertext = kemencaps($k, <$k, ~eseed>, kempk($k, ~ltkC))
    clauth_ss = kemdecaps($k, ciphertext, ~ltkC)
    messages = <messages, KemEncapsulation>

    verify_data = compute_finished(client)

    messages = <messages, Finished>

    ms = MasterSecret
    rms = resumption_master_secret()
    
    app_keyc = keygen(cats, app_key_label())
    // we compute this in KEMTLS when SFIN is received
    //app_keys = keygen(sats, app_key_label())

    // auth_status = <cas, sas>
    auth_status = <'auth', 'auth'>
in
    [ State(C3a, tid, C, S, PrevClientState)[no_precomp],
      In(senc{KemEncapsulation}ahs_keys)
    ]
  --[ C3a(tid),
      Instance(tid, C, 'client'),
      running_client(Transcript, messages),
      running_client(MS, clauth_ss, ms),
      running_client(AHSMS, ahs, ms, clauth_ss),
      running_client(HSAHSMS, hs, ahs, ms),
      running_client(RMS, S, rms, messages),
      running_client(Mode, psk_ke_mode)
    ]->
    [ State(C3b, tid, C, S, ClientState),
      Out(senc{Finished}ahs_keyc),
      SendStream(tid, C, S, auth_status, app_keyc)
    ]

rule recv_server_auth:
let
    set_state()

    S = $S
    C = $C

    exp_verify_data = compute_finished(server)

    messages = <messages, Finished>

    sats = application_traffic_secret_0(server)
    app_keys = keygen(sats, app_key_label())

    // no changes to auth
    auth_status = prev_auth_status
in
    [ State(C3b, tid, C, S, PrevClientState)[no_precomp],
      In(senc{Finished}ahs_keys),
      SendStream(tid, C, S, prev_auth_status, app_keyc)
    ]
  --[ C3b(tid),
      Instance(tid, C, 'client'),
      commit_client(HS, hs),
      commit_client(AHS, ahs),
      commit_client(MS, ms),
      Eq(verify_data, exp_verify_data),
      commit_client(Transcript, messages),
      commit_client(Identity, S, auth_status),
      SessionKey(tid, C, S, auth_status, <app_keyc, app_keys>)
    ]->
    [ State(C4, tid, C, S, ClientState),
      RecvStream(tid, C, S, auth_status, app_keys),
      SendStream(tid, C, S, auth_status, app_keyc)
    ]