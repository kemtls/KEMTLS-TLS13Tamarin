
theory Mutual_Authentication_Agreement 
begin

builtins: diffie-hellman, hashing, symmetric-encryption, signing

section{* TLS 1.3 *}

/*
 * Protocol:    TLS 1.3 Handshake and Record Protocols
 * Modeler:     Cas Cremers, Marko Horvat, Sam Scott, Thyla van der Merwe
 * Year:        2016
 * Source:      http://tlswg.github.io/tls13-spec/
 *
 * Status:  in progress....
 */

// Hash declarations

functions: Expand/3, Extract/2, hmac/1, mac/1, mask/2, unmask/2

equations: unmask(mask(x, y), y) = x, unmask(mask(x, y), x) = y

/* AXIOMS */

/* Explicit equality checking */
restriction Eq_check_succeed: "All x y #i. Eq(x,y) @ i ==> x = y"
restriction Neq_check_succeed: "All x y #i. Neq(x,y) @ i ==> not (x = y)"

/* Generate one long-term key per actor */
restriction one_ltk:
  "All A x y #i #j.
    GenLtk(A, x)@i & GenLtk(A, y)@j ==> #i = #j"

restriction one_role_per_actor:
    "All actor tid tid2 role role2 #i #j. Start(tid, actor, role)@i & Start(tid2, actor, role2)@j
        ==> role = role2"

// crypto.m4i imports

functions: kempk/2,kemencaps/3,kemdecaps/3

equations:
    kemdecaps(g, kemencaps(g, ss, kempk(g, sk)), sk) = ss
// msgs.m4i imports

// state.m4i imports

/* ------- Public key infrastructure -------*/

/*
  Register PK
  ----------------
  
  Generates a long-term key for a party.

  Premises:
    Fr(~ltkA) - a fresh value for the key itself

  Actions:
    GenLtk($A, ~ltkA) - party $A has generated a long-term key

  Conclusions:
    !Ltk($A, ~ltkA) - binds the long-term key to the party $A
    !Pk($A, pk(~ltkA)) - models the distribution of the public key by some PKI
    Out(pk(~ltkA)) - outputs the public key so the adversary has knowledge
*/
rule Register_pk:
  [ Fr(~ltkA) ]--[ GenLtk($A, ~ltkA), HonestUse(~ltkA)
  ]->
  [ !Ltk($A, ~ltkA), !Pk($A, pk(~ltkA)), MessageOut(pk(~ltkA)) ]

/*
  Reveal Ltk
  ----------------
  
  The adversarial capability to reveal long-term keys of parties.

  Premises:
    !Ltk($A, ~ltkA) - the long-term key to compromise

  Actions:
    RevLtk($A) - adversary has revealed the key of $A.

  Conclusions:
    Out(~ltkA) - provides the adversary with the long-term key
*/
rule Reveal_Ltk:
  [ !Ltk($A, ~ltkA) ] --[ RevLtk($A) ]-> [ MessageOut(~ltkA) ]

rule client_hello:
let
    // Initialise state variables to zero.
     messages = '0'
res_psk = '0'
nc = '0'
ns = '0'
g = '0'
sg = '0'
hrr = '0'
x = '0'
y = '0'
gx = '0'
gy = '0'
gxy = '0'
psk_ke_mode = 'na'
psk_id = '0'
edi = '0'
es = '0'
hs = '0'
ms = '0'
cats = '0'
sats = '0'
hs_keyc = '0'
hs_keys = '0'
auth_status = <'0', '0'>
ems = '0'
rms = '0'
cert_req = '0'

    // Abstract client identity - does not currently correspond to
    // anything concrete
    C = $C

    // Server identity - can be interpreted as the hostname
    S = $S

    // Client nonce
    nc = ~nc

    // We reuse the client nonce to be a thread identifier
    tid = nc

    // Group=kem alg, KEM private key, key share
    // this has some legacy from when this was based on dh
    g1 = $g1
    g2 = $g2
    sg = <g1, g2>
    client_sg = <g1, g2>
    g = g1
    x = ~x
    gx = kempk(g, x)

    messages = <messages, <'1','0x0303',nc,'0',$cipher_suites,'0',<<'43','0x0304'>,<'10',client_sg>,<'13',$sig_algs>,<'40',g,gx> > >>
    es = Extract(res_psk, '0')
in
    [ Fr(nc),
      Fr(x)
    ]
  --[ C0(tid),
      Start(tid, C, 'client'),
      RIdentity(tid, C, 'client', <C>),
      Neq(g1, g2),
      DH(tid, C, x),
      KemSk(tid, C, x),
      HonestUse(~x),
      HonestUse(gx)
    ]->
    [
      State_C1(tid,C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      DHExp(x, tid, C),
      KemSk(x, tid, C),
    // Write the ClientHelloMsg onto the wire *presumably* with destination S
      MessageOut(<'1','0x0303',nc,'0',$cipher_suites,'0',<<'43','0x0304'>,<'10',client_sg>,<'13',$sig_algs>,<'40',g,gx> > >)
    ]

rule recv_hello_retry_request:
let
    g1 = $g1
    g2 = $g2
    prev_sg = <g1, g2>
    prev_g = g1
    prev_hrr = '0'
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    hrr = 'hrr'
    new_g = g2
    g = g2
    client_sg = <g1, g2>

    C = $C
    S = $S

    new_x = ~new_x
    x = new_x
    gx = kempk(g, x)

    // PSK after HRR has its own rule (see recv_hello_retry_request_psk)
    psk_ke_mode = 'na'
    auth_status = <'0', '0'>

    messages = <messages, <'6',    '0x0303',    <<'40',new_g>> >>
    messages = <messages, <'1','0x0303',nc,'0',$cipher_suites,'0',<<'43','0x0304'>,<'10',client_sg>,<'13',$sig_algs>,<'40',g,gx> > >>
    es = Extract(res_psk, '0')
in
    [ State_C1(tid,C,S, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req ),
      Fr(new_x),
      F_MessageIn(<'6',    '0x0303',    <<'40',new_g>> >),
      DHExp(prev_x, tid, C)
    ]
  --[ C1_retry(tid),
      Neq(g1, g2),
      Instance(tid, C, 'client'),
      DeleteDH(tid, C, prev_x),
      DH(tid, C, x)
    ]->
    [ MessageOut(<'1','0x0303',nc,'0',$cipher_suites,'0',<<'43','0x0304'>,<'10',client_sg>,<'13',$sig_algs>,<'40',g,gx> > >),
      DHExp(x, tid, C),
      State_C1(tid,C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

rule recv_server_hello:
let
    prev_g = $g
    prev_x = ~x

    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    ns = new_ns
    gy = new_gy

    C = $C
    S = $S

    // equivalent to checking gy in <$g>
    ss = <gx, new_y>
    gy = kemencaps(g, ss, gx)

    // Derive the shared secret
    gxy = kemdecaps(g, gy, x)

    // Received a basic server hello - abandon PSK mode (if attempted)
    psk_ke_mode = 'na'
    auth_status = <'0', '0'>

    messages = <messages, <'2',  '0x0303',  ns,  $cipher_suite,  <<'13',$sig_algs>,<'40',g,gy>> >>
in
    [ State_C1(tid,C,S, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp],
      F_MessageIn(<'2',  '0x0303',  ns,  $cipher_suite,  <<'13',$sig_algs>,<'40',g,gy>> >)
    ]
  --[ C1(tid),
      Instance(tid, C, 'client'),
      Neq(gy, g),
      Neq(gxy, g),
      DHChal(g, x, new_y, gx, gy, gxy),
      RNonces(tid, C, 'client', <nc,ns>)
    ]->
    [
      State_C2a(tid,C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

rule client_gen_keys:
let
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    C = $C
    S = $S

    hs = Extract(gxy, es)
    ms = Extract('0', hs)

    hs_keyc = Expand(Expand(hs, <'clienthts', <h(messages)>>, '32'), <'kshe_wk', '0'>, '32')
    hs_keys = Expand(Expand(hs, <'serverhts', <h(messages)>>, '32'), <'kshe_wk', '0'>, '32')

in
    [ State_C2a(tid,C,S, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp],
      DHExp(x, tid, C)
    ]
  --[ C2a(tid),
      Instance(tid, C, 'client'),
      RMS(tid, C, 'client', <ms>),
      RHS(tid, C, 'client', <hs>),
      DeleteDH(tid, C, x)
    ]->
    [
      State_C2b(tid,C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

rule recv_encrypted_extensions:
let
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    S = $S
    C = $C

    messages = <messages, <'8',$exts>>

in
    [ State_C2b(tid,C,S, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp],
      F_MessageIn(senc{<'8',$exts>}hs_keys)
    ]
  --[ C2b(tid),
      Instance(tid, C, 'client')
    ]->
    [ State_C2c(tid,C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

rule recv_certificate_request:
let
    prev_psk_ke_mode ='na'
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    S = $S
    C = $C

    certificate_request_context = '0' 
    cert_req = '1'
    messages = <messages,  <'13',  certificate_request_context,  $certificate_extensions >>

in
    [ State_C2c(tid,C,S, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp],
      F_MessageIn(senc{ <'13',  certificate_request_context,  $certificate_extensions >}hs_keys)
    ]
  --[ C2c_req(tid),
      Instance(tid, C, 'client')
    ]->
    [ State_C2d(tid,C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

rule skip_recv_certificate_request:
let
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    S = $S
    C = $C
    cert_req = '0'
in
    [ State_C2c(tid,C,S, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp]
    ]
  --[ C2c(tid),
      Instance(tid, C, 'client')
    ]->
    [ State_C2d(tid,C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

rule recv_server_auth:
let
    prev_psk_ke_mode = 'na'
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    S = $S
    C = $C

    certificate_request_context = '0'
    certificate = pk(~ltkS)
    messages = <messages, <'11',certificate_request_context,certificate>>
    sig_messages = <'server_cv', <h(messages)>>

    messages = <messages, <'15',  signature >>

    exp_verify_data = hmac(Expand(Expand(hs, <'serverhts', <h(messages)>>, '32'), <'fin', '0'>, '32'), h(messages))

    messages = <messages, <'20',verify_data>>

    cats = Expand(ms, <'clientats', <h(messages)>>, '32')
    sats = Expand(ms, <'serverats', <h(messages)>>, '32')
    app_keys = Expand(sats, <'adke_wk', '0'>, '32')
    ems = Expand(ms, <'ems', <h(messages)>>, '32')

    // auth_status = <cas, sas>
    auth_status = <'0', 'auth'>
in
    [ State_C2d(tid,C,S, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp],
      !Pk(S, pk(~ltkS)),
      F_MessageIn(senc{<'11',certificate_request_context,certificate>,<'15',  signature >,<'20',verify_data>}hs_keys)
    ]
  --[ C2d(tid),
      Instance(tid, C, 'client'),
      Eq(psk_ke_mode, 'na'),
      Eq(verify(signature, sig_messages, pk(~ltkS)), true),
      Eq(verify_data, exp_verify_data),
      RMode(tid, C, 'client', <psk_ke_mode>),
      CIdentity(tid, C, 'client', <<S,auth_status>>),
      CHS(tid, C, 'client', <hs>),
      CTranscript(tid, C, 'client', <messages>),
      CNonces(tid, C, 'client', <nc,ns>)
    ]->
    [ State_C3(tid,C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      RecvStream(tid, C, S, auth_status, app_keys)
    ]

rule client_auth:
let
    // If certificate was requested, cannot ignore
    prev_cert_req = '0'
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    S = $S
    C = $C

    verify_data = hmac(Expand(Expand(hs, <'clienthts', <h(messages)>>, '32'), <'fin', '0'>, '32'), h(messages))

    messages = <messages, <'20',verify_data>>

    rms = Expand(ms, <'rms', <h(messages)>>, '32')
    app_keyc = Expand(cats, <'adke_wk', '0'>, '32')
    app_keys = Expand(sats, <'adke_wk', '0'>, '32')
in

    [ State_C3(tid,C,S, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp]
    ]
  --[ C3(tid),
      Instance(tid, C, 'client'),
      RTranscript(tid, C, 'client', <messages>),
      RHSMS(tid, C, 'client', <hs,ms>),
      RRMS(tid, C, 'client', <S,rms,messages>),
      RMode(tid, C, 'client', <psk_ke_mode>),
      SessionKey(tid, C, S, auth_status, <app_keyc, app_keys>)
    ]->
    [ State_C4(tid,C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      MessageOut(senc{<'20',verify_data>}hs_keyc),
      SendStream(tid, C, S, auth_status, app_keyc)
    ]

rule client_auth_cert:
let
    prev_cert_req = '1'
    prev_psk_ke_mode = 'na'
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    S = $S
    C = $C

    certificate_request_context = '0' 
    certificate = pk(~ltkC)
    messages = <prev_messages, <'11',certificate_request_context,certificate>>

    signature = sign{<'client_cv', <h(messages)>>}~ltkC
    messages = <messages, <'15',  signature >>

    verify_data = hmac(Expand(Expand(hs, <'clienthts', <h(messages)>>, '32'), <'fin', '0'>, '32'), h(messages))
    messages = <messages, <'20',verify_data>>

    rms = Expand(ms, <'rms', <h(messages)>>, '32')

    // zeroes cert_req after it has been used
    cert_req = '0'

    app_keyc = Expand(cats, <'adke_wk', '0'>, '32')
    app_keys = Expand(sats, <'adke_wk', '0'>, '32')

    auth_status = <'auth', 'auth'>
in

    [ State_C3(tid,C,S, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp],
      RecvStream(tid, C, S, prev_auth_status, app_keys),
      !Ltk(C, ~ltkC)
    ]
  --[ C3_cert(tid),
      Instance(tid, C, 'client'),
      UseLtk(~ltkC, signature),
      RHSMS(tid, C, 'client', <hs,ms>),
      RTranscript(tid, C, 'client', <messages>),
      RRMS(tid, C, 'client', <S,rms,messages>),
      RMode(tid, C, 'client', <psk_ke_mode>),
      SessionKey(tid, C, S, auth_status, <app_keyc, app_keys>)
    ]->
    [ State_C4(tid,C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      MessageOut(senc{<'11',certificate_request_context,certificate>,<'15',  signature >,<'20',verify_data>}hs_keyc),
      SendStream(tid, C, S, auth_status, app_keyc),
      RecvStream(tid, C, S, auth_status, app_keys)
    ]

rule start_server:
let
    C = $C
    S = $S

    // Initialises all variables to zero.
     messages = '0'
res_psk = '0'
nc = '0'
ns = '0'
g = '0'
sg = '0'
hrr = '0'
x = '0'
y = '0'
gx = '0'
gy = '0'
gxy = '0'
psk_ke_mode = 'na'
psk_id = '0'
edi = '0'
es = '0'
hs = '0'
ms = '0'
cats = '0'
sats = '0'
hs_keyc = '0'
hs_keys = '0'
auth_status = <'0', '0'>
ems = '0'
rms = '0'
cert_req = '0'

    tid = ~tid
    sg = $g
in
    [ Fr(tid)
    ]
  --[ Start(tid, S, 'server'),
      RIdentity(tid, S, 'server', <S>)
    ]->
    [
      State_S0(tid,S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

/*
    Server receives vanilla ClientHello
*/

rule recv_client_hello:
let
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    psk_ke_mode = 'na'
    g1 = $g1
    g2 = $g2
    client_sg = <g1, g2>
    nc = new_nc
    gx = new_gx
    g = $new_g
    gx = kempk(g, new_x)

    // Abstract client identity - does not currently correspond to
    // anything concrete
    // From the server's perspective: associate with an open socket.
    C = $C

    // Server identity - can be interpreted as the hostname
    S = $S

    // Server nonce
    ns = ~new_ns

    messages = <messages, <'1','0x0303',nc,'0',$cipher_suites,'0',<<'43','0x0304'>,<'10',client_sg>,<'13',$sig_algs>,<'40',g,gx> > >>

    psk_ke_mode = 'na'

in
    [ F_MessageIn(<'1','0x0303',nc,'0',$cipher_suites,'0',<<'43','0x0304'>,<'10',client_sg>,<'13',$sig_algs>,<'40',g,gx> > >),
      Fr(ns),
      State_S0(tid,S,C, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp]
    ]
  --[ S0(tid),
      Neq(g1, g2)
    ]->
    [
      State_S1(tid,S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

rule hello_retry_request:
let
    // Cannot HRR twice in a handshake
    prev_hrr = '0'
    prev_sg = $prev_sg
    // Copies across all values from  prev_res_psk, prev_messages, prev_nc, prev_ns, prev_g, prev_sg, prev_hrr, prev_x, prev_y, prev_gx, prev_gy, prev_gxy, prev_psk_ke_mode, prev_psk_id, prev_edi, prev_es, prev_hs, prev_ms, prev_cats, prev_sats, prev_hs_keyc, prev_hs_keys, prev_auth_status, prev_ems, prev_rms, prev_cert_req  to  res_psk, messages, nc, ns, g, sg, hrr, x, y, gx, gy, gxy, psk_ke_mode, psk_id, edi, es, hs, ms, cats, sats, hs_keyc, hs_keys, auth_status, ems, rms, cert_req 
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    hrr = 'hrr'
    new_g = sg
    g = sg

    C = $C
    S = $S

    messages = <messages, <'6',    '0x0303',    <<'40',new_g>> >>

in
    [ State_S1(tid,S,C, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp]
    ]
  --[ S1_retry(tid),
      Neq(prev_g, sg),
      Instance(tid, S, 'server')
    ]->
    [ MessageOut(<'6',    '0x0303',    <<'40',new_g>> >),
      State_S0(tid,S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

/*
    Server sends basic ServerHello
*/

rule server_hello:
let
    prev_g = $prev_g
    prev_gx = kempk(prev_g, some_x)
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    // Server continuing in normal mode (no PSK mode)
    psk_ke_mode = 'na'
    auth_status = <'0', '0'>

    C = $C
    S = $S

    // Group, DH exponent, key share
    y = ~y
    ss = <gx, y>
    gy = kemencaps(g, ss, gx)
    gxy = ss

    es = Extract(res_psk, '0')
    messages = <messages, <'2',  '0x0303',  ns,  $cipher_suite,  <<'13',$sig_algs>,<'40',g,gy>> >>
in
    [ State_S1(tid,S,C, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req ),
      Fr(y)
    ]
  --[ S1(tid),
      Eq(g, sg),
      Neq(gx, g),
      Neq(gxy, g),
      Instance(tid, S, 'server'),
      RNonces(tid, S, 'server', <nc,ns>),
      DHChal(g, some_x, y, gx, gy, gxy),
      DH(tid, S, y)
    ]->
    [
      State_S2a(tid,S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      DHExp(y, tid, S),
      MessageOut(<'2',  '0x0303',  ns,  $cipher_suite,  <<'13',$sig_algs>,<'40',g,gy>> >)
    ]

rule server_gen_keys:
let
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    S = $S
    C = $C

    hs = Extract(gxy, es)
    ms = Extract('0', hs)

    hs_keys = Expand(Expand(hs, <'serverhts', <h(messages)>>, '32'), <'kshe_wk', '0'>, '32')
    hs_keyc = Expand(Expand(hs, <'clienthts', <h(messages)>>, '32'), <'kshe_wk', '0'>, '32')
in
    [ State_S2a(tid,S,C, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp],
      DHExp(y, tid, S)
    ]
  --[ S2a(tid),
      Extract('0', hs),
      Instance(tid, S, 'server'),
      RHS(tid, S, 'server', <hs>),
      RMS(tid, S, 'server', <ms>),
      DeleteDH(tid, S, y)
   ]->
    [ State_S2b(tid,S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

rule encrypted_extensions:
let
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    S = $S
    C = $C

    messages = <messages, <'8',$exts>>
in
    [ State_S2b(tid,S,C, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp]
    ]
  --[ S2b(tid),
      Instance(tid, S, 'server')
    ]->
    [ State_S2c(tid,S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      MessageOut(senc{<'8',$exts>}hs_keys)
    ]

rule certificate_request:
let
    prev_psk_ke_mode = 'na'
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    S = $S
    C = $C

    certificate_request_context = '0' 
    cert_req = '1' 
    messages = <messages,  <'13',  certificate_request_context,  $certificate_extensions >>
in
    [ State_S2c(tid,S,C, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp]
    ]
  --[ S2c_req(tid),
      Instance(tid, S, 'server'),
      RCertReqCtxt(tid, S, 'server', <certificate_request_context>)
    ]->
    [ State_S2d(tid,S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      MessageOut(senc{ <'13',  certificate_request_context,  $certificate_extensions >}hs_keys)
    ]

rule skip_certificate_request:
let
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    cert_req = '0'

    S = $S
    C = $C
in
    [ State_S2c(tid,S,C, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp]
    ]
  --[ S2c(tid),
      Instance(tid, S, 'server')
    ]->
    [ State_S2d(tid,S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req )
    ]

rule server_auth:
let
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    C = $C
    S = $S

    certificate_request_context = '0'
    certificate = pk(~ltkS)
    messages = <messages, <'11',certificate_request_context,certificate>>
    signature = sign{<'server_cv', <h(messages)>>}~ltkS

    messages = <messages, <'15',  signature >>

    verify_data = hmac(Expand(Expand(hs, <'serverhts', <h(messages)>>, '32'), <'fin', '0'>, '32'), h(messages))

    messages = <messages, <'20',verify_data>>
    ems = Expand(ms, <'ems', <h(messages)>>, '32')
    cats = Expand(ms, <'clientats', <h(messages)>>, '32')
    sats = Expand(ms, <'serverats', <h(messages)>>, '32')
    app_keys = Expand(sats, <'adke_wk', '0'>, '32')

    // auth_status = <sas, cas>
    auth_status = <'auth', '0'>
in
    [ State_S2d(tid,S,C, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp],
      !Ltk(S, ~ltkS)
    ]
  --[ S2d(tid),
      Instance(tid, S, 'server'),
      Eq(psk_ke_mode, 'na'),
      UseLtk(~ltkS, signature),
      RTranscript(tid, S, 'server', <messages>)
    ]->
    [ State_S3(tid,S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      SendStream(tid, S, C, auth_status, app_keys),
      MessageOut(senc{<'11',certificate_request_context,certificate>,<'15',  signature >,<'20',verify_data>}hs_keys)
    ]

rule recv_client_auth:
let
    prev_cert_req = '0'
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    C = $C
    S = $S

    exp_verify_data = hmac(Expand(Expand(hs, <'clienthts', <h(messages)>>, '32'), <'fin', '0'>, '32'), h(messages))

    messages = <messages, <'20',verify_data>>

    rms = Expand(ms, <'rms', <h(messages)>>, '32')

    app_keyc = Expand(cats, <'adke_wk', '0'>, '32')
    app_keys = Expand(sats, <'adke_wk', '0'>, '32')
in
    [ State_S3(tid,S,C, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp],
      F_MessageIn(senc{<'20',verify_data>}hs_keyc)
    ]
  --[ S3(tid),
      Instance(tid, S, 'server'),
      Eq(verify_data, exp_verify_data),
      RMode(tid, S, 'server', <psk_ke_mode>),
      CIdentity(tid, S, 'server', <C,auth_status>),
      CHS(tid, S, 'server', <hs>),
      RHSMS(tid, S, 'server', <hs,ms>),
      RRMS(tid, S, 'server', <C,rms,messages>),
      CTranscript(tid, S, 'server', <messages>),
      CNonces(tid, S, 'server', <nc,ns>),
      SessionKey(tid, S, C, auth_status, <app_keys, app_keyc>)
    ]->
    [ State_S4(tid,S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      RecvStream(tid, S, C, auth_status, app_keyc)
    ]

rule recv_client_auth_cert:
let
    prev_cert_req = '1'
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    C = $C
    S = $S

    certificate = pk(~ltkC)
    certificate_request_context ='0' 
    messages = <messages, <'11',certificate_request_context,certificate>>

    sig_messages = <'client_cv', <h(messages)>>
    messages = <messages, <'15',  signature >>

    exp_verify_data = hmac(Expand(Expand(hs, <'clienthts', <h(messages)>>, '32'), <'fin', '0'>, '32'), h(messages))

    messages = <messages, <'20',verify_data>>
    rms = Expand(ms, <'rms', <h(messages)>>, '32')

    cert_req = '0'
    auth_status = <'auth', 'auth'>

    app_keyc = Expand(cats, <'adke_wk', '0'>, '32')
    app_keys = Expand(sats, <'adke_wk', '0'>, '32')
in
    [ State_S3(tid,S,C, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp],
      !Pk(C, pk(~ltkC)),
      SendStream(tid, S, C, prev_auth_status, app_keys),
      F_MessageIn(senc{<'11',certificate_request_context,certificate>,<'15',  signature >,<'20',verify_data>}hs_keyc)
    ]
  --[ S3_cert(tid),
      Instance(tid, S, 'server'),
      Eq(verify(signature, sig_messages, pk(~ltkC)), true),
      Eq(verify_data, exp_verify_data),
      RMode(tid, S, 'server', <psk_ke_mode>),
      CIdentity(tid, S, 'server', <C,auth_status>),
      CHS(tid, S, 'server', <hs>),
      RHSMS(tid, S, 'server', <hs,ms>),
      RRMS(tid, S, 'server', <C,rms,messages>),
      CTranscript(tid, S, 'server', <messages>),
      SessionKey(tid, S, C, auth_status, <app_keys, app_keyc>),
      CNonces(tid, S, 'server', <nc,ns>)
    ]->
    [ State_S4(tid,S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      SendStream(tid, S, C, auth_status, app_keys),
      RecvStream(tid, S, C, auth_status, app_keyc)
    ]

rule send:
    [ SendStream(~tid, $actor, $peer, auth_status, app_key_out),
      Fr(~data)
    ]
  --[ Send(~tid),
      SendData(~tid, $actor, $peer, auth_status, ~data)
    ]->
    [ SendStream(~tid, $actor, $peer, auth_status, app_key_out),
      MessageOut(senc{<~data,'23'>}app_key_out)
    ]

rule recv:
    [ RecvStream(~tid, $actor, $peer, auth_status, app_key_in),
      F_MessageIn(senc{<data,'23'>}app_key_in)
    ]
  --[ Recv(~tid),
      RecvData(~tid, $actor, $peer, auth_status, data)
    ]->
    [
      RecvStream(~tid, $actor, $peer, auth_status, app_key_in)
    ]

rule out_of_band_psk:
let
    C = $C
    S = $S
    res_psk = ~res_psk
    ticket = ~ticket
    ticket_age_add = ~ticket_age_add

    // Implicitly authed perhaps...
    auth_status = <'oob_auth', 'oob_auth'>
in
    [ Fr(ticket), Fr(res_psk), Fr(~ticket_age_add)]
  --[ GenPSK(S, 'server'), GenPSK(C, 'client'),
      FreshPSK(ticket,res_psk)
    ]->
    [ !ClientPSK(C, S, res_psk, auth_status, <'4',$ticket_lifetime,ticket_age_add,ticket,<<'46',$max_early_data_size>> >, 'ext'),
      !ServerPSK(S, C, res_psk, auth_status, <'4',$ticket_lifetime,ticket_age_add,ticket,<<'46',$max_early_data_size>> >, 'ext'),
      SecretPSK(S, res_psk),
      SecretPSK(C, res_psk)
    ]

rule new_session_ticket:
let
    prev_rms = Expand(ms, <'rms', <h(messages)>>, '32')
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    C = $C
    S = $S

    ticket = ~ticket
    ticket_age_add = ~ticket_age_add

    res_psk = rms
in
    [ State_S4(tid,S,C, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp],
      SendStream(tid, S, C, auth_status, app_keys),
      Fr(ticket),
      Fr(ticket_age_add)
    ]
  --[ S4_NST(tid),
      Instance(tid, S, 'server'),
      RPostHS(tid, S, 'server', <hs,rms,C,auth_status,messages>),
      RNST(tid, S, 'server', <ticket,ticket_age_add>)
    ]->
    [ State_S4(tid,S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      SendStream(tid, S, C, auth_status, app_keys),
      !ServerPSK(S, C, res_psk, auth_status, <'4',$ticket_lifetime,ticket_age_add,ticket,<<'46',$max_early_data_size>> >, 'res'),
      SecretPSK(S, res_psk),
      MessageOut(senc{<'4',$ticket_lifetime,ticket_age_add,ticket,<<'46',$max_early_data_size>> >}app_keys)
    ]

rule recv_new_session_ticket:
let
    prev_rms = Expand(ms, <'rms', <h(messages)>>, '32')
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    C = $C
    S = $S

    res_psk = rms
in
    [ State_C4(tid,C,S, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp],
      RecvStream(tid, C, S, auth_status, app_keys),
      F_MessageIn(senc{<'4',$ticket_lifetime,ticket_age_add,ticket,<<'46',$max_early_data_size>> >}app_keys)
    ]
  --[ C4_NST(tid),
      Instance(tid, C, 'client'),
      RPostHS(tid, C, 'client', <hs,rms,S,auth_status,messages>)
    ]->
    [ State_C4(tid,C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      RecvStream(tid, C, S, auth_status, app_keys),
      !ClientPSK(C, S, res_psk, auth_status, <'4',$ticket_lifetime,ticket_age_add,ticket,<<'46',$max_early_data_size>> >, 'res'),
      SecretPSK(C, res_psk)
    ]

rule certificate_request_post:
let
//    prev_cert_req_ctxt = '0'
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    S = $S
    C = $C

    certificate_request_context = ~cert_req_ctxt
//    cert_req_ctxt = ~cert_req_ctxt
in
    [ State_S4(tid,S,C, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp],
      SendStream(tid, S, C, prev_auth_status, app_keys),
      Fr(certificate_request_context)
    ]
  --[ S4_req(tid),
      Instance(tid, S, 'server'),
      RCertReqCtxt(tid, S, 'server', <certificate_request_context>),
      RPostHS(tid, S, 'server', <hs,rms,C,auth_status,messages>)
    ]->
    [ State_S4(tid,S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      SendStream(tid, S, C, auth_status, app_keys),
      ServerCertReq(tid, S, C, certificate_request_context),
      MessageOut(senc{ <'13',  certificate_request_context,  $certificate_extensions >}app_keys)
    ]

rule recv_certificate_request_post:
let
//    prev_cert_req_ctxt = '0'
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    S = $S
    C = $C

//    cert_req_ctxt = certificate_request_context
in
    [ State_C4(tid,C,S, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp],
      RecvStream(tid, C, S, prev_auth_status, app_keys),
      F_MessageIn(senc{ <'13',  certificate_request_context,  $certificate_extensions >}app_keys)
    ]
  --[ C4_req(tid),
      Neq(certificate_request_context, '0'),
      Instance(tid, C, 'client'),
      RPostHS(tid, C, 'client', <hs,rms,S,auth_status,messages>)
    ]->
    [ State_C4(tid,C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      RecvStream(tid, C, S, auth_status, app_keys),
      ClientCertReq(tid, C, S, certificate_request_context)
    ]

rule client_auth_post:
let
  prev_auth_status = <prev_cas, prev_sas>
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    S = $S
    C = $C

//    certificate_request_context = prev_cert_req_ctxt
    certificate = pk(~ltkC)

    tmp_messages = messages
    messages = <messages,  <'13',  certificate_request_context,  $certificate_extensions >>

    signature = sign{<'client_cv', <h(messages)>>}~ltkC

    fin_keyc = Expand(cats, <'fin', '0'>, '32')
    verify_data = hmac(Expand(Expand(hs, <'fin_keychts', <h(messages)>>, '32'), <'fin', '0'>, '32'), h(messages))

//    cert_req_ctxt = '0'
    messages = tmp_messages

    auth_status = <'auth', prev_sas>
in

    [ State_C4(tid,C,S, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp],
      SendStream(tid, C, S, prev_auth_status, app_keyc),
      !Ltk(C, ~ltkC),
      ClientCertReq(tid, C, S, certificate_request_context)
    ]
  --[ C4_cert(tid),
      Instance(tid, C, 'client'),
      Neq(certificate_request_context, '0'),
      UseLtk(~ltkC, signature),
      RTranscriptPost(tid, C, 'client', <messages,certificate_request_context>),
      RPostHS(tid, C, 'client', <hs,rms,S,auth_status,messages>)
    ]->
    [ State_C4(tid,C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      SendStream(tid, C, S, auth_status, app_keyc),
      MessageOut(senc{<'11',certificate_request_context,certificate>,<'15',  signature >,<'20',verify_data>}app_keyc)
    ]

rule recv_client_auth_post:
let
    prev_auth_status = <prev_sas, prev_cas>
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    C = $C
    S = $S

    certificate = pk(~ltkC)
    certificate_request_context = ~cert_req_ctxt

    tmp_messages = messages
    messages = <messages,  <'13',  certificate_request_context,  $certificate_extensions >>

    sig_messages = <'client_cv', <h(messages)>>

    fin_keyc = Expand(cats, <'fin', '0'>, '32')
    exp_verify_data = hmac(Expand(Expand(hs, <'fin_keychts', <h(messages)>>, '32'), <'fin', '0'>, '32'), h(messages))

//    cert_req_ctxt = '0'
    auth_status = <prev_sas, 'auth'>
    messages = tmp_messages
in
    [ State_S4(tid,S,C, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp],
      RecvStream(tid, S, C, prev_auth_status, app_keyc),
      !Pk(C, pk(~ltkC)),
      ServerCertReq(tid, S, C, certificate_request_context),
      F_MessageIn(senc{<'11',certificate_request_context,certificate>,<'15',  signature >,<'20',verify_data>}app_keyc)
    ]
  --[ S4_cert(tid),
      Instance(tid, S, 'server'),
      Neq(certificate_request_context, '0'),
      Eq(verify(signature, sig_messages, pk(~ltkC)), true),
      Eq(verify_data, exp_verify_data),
      CIdentityPost(tid, S, 'server', <<C,auth_status>>),
      CTranscriptPost(tid, S, 'server', <messages,certificate_request_context>),
      CHS(tid, S, 'server', <hs>),
      RPostHS(tid, S, 'server', <hs,rms,C,auth_status,messages>)
    ]->
    [ State_S4(tid,S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      RecvStream(tid, S, C, auth_status, app_keyc)
    ]

rule update_req_client:
let
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    C = $C
    S = $S

    cats = Expand(prev_cats, <'ats', '0'>, '32')
    app_keyc = Expand(cats, <'adke_wk', '0'>, '32')
in
    [ State_C4(tid,C,S, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp],
      SendStream(tid, C, S, prev_auth_status, prev_app_keyc)
    ]
  --[ C4_update_req(tid),
      Instance(tid, C, 'client'),
      RPostHS(tid, C, 'client', <hs,rms,S,auth_status,messages>)
    ]->
    [ State_C4(tid,C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      SendStream(tid, C, S, auth_status, app_keyc),
      MessageOut(senc{<'24','1'>}prev_app_keyc)
    ]

rule update_req_server:
let
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    C = $C
    S = $S

    sats = Expand(prev_sats, <'ats', '0'>, '32')
    app_keys = Expand(sats, <'adke_wk', '0'>, '32')
in
    [ State_S4(tid,S,C, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp],
      SendStream(tid, S, C, prev_auth_status, prev_app_keys)
    ]
  --[ S4_update_req(tid),
      Instance(tid, S, 'server'),
      RPostHS(tid, S, 'server', <hs,rms,C,auth_status,messages>)
    ]->
    [ State_S4(tid,S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      SendStream(tid, S, C, auth_status, app_keys),
      MessageOut(senc{<'24','1'>}prev_app_keys)
    ]

rule update_recv_client:
let
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    C = $C
    S = $S

    cats = Expand(prev_cats, <'ats', '0'>, '32')
    sats = Expand(prev_sats, <'ats', '0'>, '32')
    app_keyc = Expand(cats, <'adke_wk', '0'>, '32')
    app_keys = Expand(sats, <'adke_wk', '0'>, '32')
in
    [ State_C4(tid,C,S, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp],
      RecvStream(tid, C, S, prev_auth_status, prev_app_keys),
      SendStream(tid, C, S, prev_auth_status, prev_app_keyc),
      F_MessageIn(senc{<'24','1'>}prev_app_keys)
    ]
  --[ C4_update_recv(tid),
      Instance(tid, C, 'client'),
      RPostHS(tid, C, 'client', <hs,rms,S,auth_status,messages>)
    ]->
    [ State_C4(tid,C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      RecvStream(tid, C, S, auth_status, app_keys),
      SendStream(tid, C, S, auth_status, app_keyc),
      MessageOut(senc{<'24','0'>}prev_app_keyc)
    ]

rule update_recv_server:
let
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    C = $C
    S = $S

    cats = Expand(prev_cats, <'ats', '0'>, '32')
    sats = Expand(prev_sats, <'ats', '0'>, '32')
    app_keyc = Expand(cats, <'adke_wk', '0'>, '32')
    app_keys = Expand(sats, <'adke_wk', '0'>, '32')
in
    [ State_S4(tid,S,C, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp],
      RecvStream(tid, S, C, prev_auth_status, prev_app_keyc),
      SendStream(tid, S, C, prev_auth_status, prev_app_keys),
      F_MessageIn(senc{<'24','1'>}prev_app_keyc)
    ]
  --[ S4_update_recv(tid),
      Instance(tid, S, 'server'),
      RPostHS(tid, S, 'server', <hs,rms,C,auth_status,messages>)
    ]->
    [ State_S4(tid,S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      RecvStream(tid, S, C, auth_status, app_keyc),
      SendStream(tid, S, C, auth_status, app_keys),
      MessageOut(senc{<'24','0'>}prev_app_keys)
    ]

rule update_fin_client:
let
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    C = $C
    S = $S

    sats = Expand(prev_sats, <'ats', '0'>, '32')
    app_keys = Expand(sats, <'adke_wk', '0'>, '32')
in
    [ State_C4(tid,C,S, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp],
      RecvStream(tid, C, S, prev_auth_status, prev_app_keys),
      F_MessageIn(senc{<'24','0'>}prev_app_keys)
    ]
  --[ C4_update_fin(tid),
      Instance(tid, C, 'client'),
      RPostHS(tid, C, 'client', <hs,rms,S,auth_status,messages>)
    ]->
    [ State_C4(tid,C,S, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      RecvStream(tid, C, S, auth_status, app_keys)
    ]

rule update_fin_server:
let
    
res_psk = prev_res_psk
nc = prev_nc
ns = prev_ns
g = prev_g
sg = prev_sg
x = prev_x
y = prev_y
gx = prev_gx
gy = prev_gy
gxy = prev_gxy
hrr = prev_hrr
psk_ke_mode = prev_psk_ke_mode
psk_id = prev_psk_id
edi = prev_edi
es = prev_es
hs = prev_hs
ms = prev_ms
cats = prev_cats
sats = prev_sats
hs_keyc = prev_hs_keyc
hs_keys = prev_hs_keys
auth_status = prev_auth_status
messages = prev_messages
ems = prev_ems
rms = prev_rms
cert_req = prev_cert_req
tid = ~tid

    C = $C
    S = $S

    cats = Expand(prev_cats, <'ats', '0'>, '32')
    app_keyc = Expand(cats, <'adke_wk', '0'>, '32')
in
    [ State_S4(tid,S,C, prev_res_psk,prev_messages,prev_nc,prev_ns,prev_g,prev_sg,prev_hrr,prev_x,prev_y,prev_gx,prev_gy,prev_gxy,prev_psk_ke_mode,prev_psk_id,prev_edi,prev_es,prev_hs,prev_ms,prev_cats,prev_sats,prev_hs_keyc,prev_hs_keys,prev_auth_status,prev_ems,prev_rms,prev_cert_req )[no_precomp],
      RecvStream(tid, S, C, prev_auth_status, prev_app_keyc),
      F_MessageIn(senc{<'24','0'>}prev_app_keyc)
    ]
  --[ S4_update_fin(tid),
      Instance(tid, S, 'server'),
      RPostHS(tid, S, 'server', <hs,rms,C,auth_status,messages>)
    ]->
    [ State_S4(tid,S,C, res_psk,messages,nc,ns,g,sg,hrr,x,y,gx,gy,gxy,psk_ke_mode,psk_id,edi,es,hs,ms,cats,sats,hs_keyc,hs_keys,auth_status,ems,rms,cert_req ),
      RecvStream(tid, S, C, auth_status, app_keyc)
    ]

rule in_out:
[MessageOut(m)]-->[F_MessageIn(m)]

lemma one_C2d_per_tid [reuse]:
    "All tid #i #j. C2d(tid)@i & C2d(tid)@j ==> #i = #j"

lemma one_S2d_per_tid [reuse]:
    "All tid #i #j. S2d(tid)@i & S2d(tid)@j ==> #i = #j"

lemma one_C3_per_tid [reuse]:
    "All tid #i #j. C3(tid)@i & C3(tid)@j ==> #i = #j"

lemma one_C3_cert_per_tid [reuse]:
    "All tid #i #j. C3_cert(tid)@i & C3_cert(tid)@j ==> #i = #j"

lemma one_S3_per_tid [reuse]:
    "All tid #i #j. S3(tid)@i & S3(tid)@j ==> #i = #j"

lemma one_S3_cert_per_tid [reuse]:
    "All tid #i #j. S3_cert(tid)@i & S3_cert(tid)@j ==> #i = #j"

lemma s3_vs_s3_cert [reuse]:
  "All tid #i #j. S3(tid)@i & S3_cert(tid)@j ==> F"

lemma c3_vs_c3_cert [reuse]:
  "All tid #i #j. C3(tid)@i & C3_cert(tid)@j ==> F"

lemma server_agree_auth [reuse]:
  "All tid tid2 actor peer auth_status_client auth_status_server data #i #j.
      SendData(tid, actor, peer, <'auth', auth_status_server>, data)@i &
      RecvData(tid2, peer, actor, <auth_status_server, auth_status_client>, data)@j
      ==> Ex #k. CIdentity(tid2, peer, 'server', <actor,<auth_status_server,'auth'>>)@k &
     #k < #j"

lemma client_agree_auth [reuse]:
  "All tid actor peer auth_status_client auth_status_server data #i.
      RecvData(tid, actor, peer, <auth_status_client, auth_status_server>, data)@i 
      ==> Ex tid2 #j. CIdentity(tid2, peer, 'server', <actor,<auth_status_server,auth_status_client>>)@j &
      #j < #i" 

end
